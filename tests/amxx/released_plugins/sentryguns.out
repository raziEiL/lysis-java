new PLUGINNAME[12] =
{
	83, 101, 110, 116, 114, 121, 32, 103, 117, 110, 115, 0
};
new VERSION[13] =
{
	48, 46, 53, 46, 52, 32, 98, 101, 116, 97, 32, 52, 0
};
new AUTHOR[5] =
{
	74, 71, 72, 71, 0
};
new g_SENTRYFRAGREWARDS[3] =
{
	300, 150, 150
};
new g_DMG[3] =
{
	5, 10, 15
};
new Float:g_THINKFREQUENCIES[3] =
{
	1073741824, 1065353216, 1056964608
};
new Float:g_HITRATIOS[3] =
{
	1058642330, 1061158912, 1062836634
};
new Float:g_HEALTHS[3] =
{
	1137180672, 1145569280, 1153957888
};
new g_COST[3] =
{
	1000, 500, 250
};
new MASKS_PEOPLE[4] =
{
	-64, -4033, -258049, -16515073
};
new MASKS_SETTINGS[4] =
{
	-4, -13, -49, -193
};
new g_sentriesNum;
new g_sentries[64];
new g_playerSentries[32];
new g_playerSentriesEdicts[32][2];
new g_sModelIndexFireball;
new g_msgDamage;
new g_msgDeathMsg;
new g_msgScoreInfo;
new g_msgHostagePos;
new g_msgHostageK;
new g_MAXPLAYERS;
new Float:g_ONEEIGHTYTHROUGHPI;
new Float:g_sentryOrigins[32][3];
new g_aimSentry[32];
new bool:g_inBuilding[32];
new bool:g_lastInBuilding[32];
new bool:g_resetArmouryThisRound = 1;
new bool:g_hasArmouries;
new Float:g_lastGameTime = 1065353216;
new Float:g_gameTime;
new Float:g_deltaTime;
new g_sentryStatusBuffer[32][256];
new g_sentryStatusTrigger;
new g_selectedSentry[32] =
{
	-1, ...
};
new g_menuId;
new g_lastObjectiveBuild[32];
new g_inSpyCam[32];
new Float:g_spyCamOffset[3] =
{
	1104150528, 1105723392, 1104150528
};
new g_FIRESOUNDS[2][0] =
{
	{
		119, ...
	},
	{
		119, ...
	}
};
new Float:g_maxSpeeds[32];
Float:operator*(Float:,_:)(Float:oper1, oper2)
{
	return floatmul(oper1, float(oper2));
}

Float:operator+(Float:,_:)(Float:oper1, oper2)
{
	return floatadd(oper1, float(oper2));
}

bool:operator==(Float:,Float:)(Float:oper1, Float:oper2)
{
	return floatcmp(oper1, oper2) == 0;
}

bool:operator!=(Float:,Float:)(Float:oper1, Float:oper2)
{
	return floatcmp(oper1, oper2) != 0;
}

bool:operator>(Float:,Float:)(Float:oper1, Float:oper2)
{
	return 0 < floatcmp(oper1, oper2);
}

bool:operator>=(Float:,Float:)(Float:oper1, Float:oper2)
{
	return 0 <= floatcmp(oper1, oper2);
}

bool:operator<(Float:,Float:)(Float:oper1, Float:oper2)
{
	return 0 > floatcmp(oper1, oper2);
}

bool:operator<=(Float:,Float:)(Float:oper1, Float:oper2)
{
	return 0 >= floatcmp(oper1, oper2);
}

bool:operator<=(Float:,_:)(Float:oper1, oper2)
{
	return 0 >= floatcmp(oper1, float(oper2));
}

FVecIVec(Float:FVec[3], IVec[3])
{
	IVec[0] = floatround(FVec[0], PLUGINNAME);
	IVec[1] = floatround(FVec[1], PLUGINNAME);
	IVec[2] = floatround(FVec[2], PLUGINNAME);
	return 1;
}

GetSentryPeople(SENTRY, WHO)
{
	new data = entity_get_int(SENTRY, 4);
	data = MASKS_PEOPLE[WHO] | data;
	data = MASKS_PEOPLE[WHO] ^ data;
	data >>>= WHO * 6;
	return data;
}

SetSentryPeople(SENTRY, WHO, IS)
{
	new data = entity_get_int(SENTRY, 4);
	data = MASKS_PEOPLE[WHO] & data;
	data = IS << WHO * 6 | data;
	entity_set_int(SENTRY, 4, data);
	return 0;
}

GetSentrySettings(SENTRY, SETTING)
{
	new data = entity_get_int(SENTRY, "");
	data = MASKS_SETTINGS[SETTING] | data;
	data = MASKS_SETTINGS[SETTING] ^ data;
	return data >>> SETTING * 2;
}

SetSentrySettings(SENTRY, SETTING, VALUE)
{
	new data = entity_get_int(SENTRY, "");
	data = MASKS_SETTINGS[SETTING] & data;
	entity_set_int(SENTRY, "", VALUE << SETTING * 2 | data);
	return 0;
}

GetSentryFiremode(SENTRY)
{
	return GetSentrySettings(SENTRY, 0);
}

SetSentryFiremode(SENTRY, MODE)
{
	SetSentrySettings(SENTRY, 0, MODE);
	return 0;
}

CsTeams:GetSentryTeam(SENTRY)
{
	return GetSentrySettings(SENTRY, 1);
}

SetSentryTeam(SENTRY, CsTeams:TEAM)
{
	SetSentrySettings(SENTRY, 1, TEAM);
	return 0;
}

GetSentryLevel(SENTRY)
{
	return GetSentrySettings(SENTRY, 2);
}

SetSentryLevel(SENTRY, LEVEL)
{
	SetSentrySettings(SENTRY, 2, LEVEL);
	return 0;
}

GetSentryPenddir(SENTRY)
{
	return GetSentrySettings(SENTRY, 3);
}

SetSentryPenddir(SENTRY, PENDDIR)
{
	SetSentrySettings(SENTRY, 3, PENDDIR);
	return 0;
}

public createsentryhere(id)
{
	new sentry = AimingAtSentry(id, true);
	new var1;
	if (sentry && entity_range(sentry, id) <= 1117126656)
	{
		new var2;
		if (GetSentryLevel(sentry) && GetSentryPeople(sentry, 0) == id)
		{
			client_print(id, 4, "You cannot upgrade your own sentry gun to level 2, a team mate must do this!");
			return 1;
		}
		new var3;
		if (GetSentryLevel(sentry) == 1 && GetSentryPeople(sentry, 1) == id)
		{
			client_print(id, 4, "You cannot upgrade this sentry gun another time to level 3, a team mate must do this!");
			return 1;
		}
		g_aimSentry[id + -1] = sentry;
		sentry_upgrade(id, sentry);
	}
	else
	{
		sentry_build(id);
	}
	return 1;
}

public sentry_build(id)
{
	if (!is_user_alive(id))
	{
		return 0;
	}
	if (2 <= GetSentryCount(id))
	{
		new wordnumbers[128];
		getnumbers(2, wordnumbers, 127);
		new maxsentries = 2;
		new var1;
		if (maxsentries != 1)
		{
			var1 = 36328;
		}
		else
		{
			var1 = 36336;
		}
		client_print(id, 4, "You can only build %s sentry gun%s!", wordnumbers, var1);
		return 0;
	}
	if (g_inBuilding[id + -1])
	{
		client_print(id, 4, "Wow, you're a fast builder...");
		return 0;
	}
	if (g_COST[0] > cs_get_user_money(id))
	{
		client_print(id, 4, "You don't have enough money to build a sentry gun! ($%d needed)", g_COST);
		return 0;
	}
	if (!entity_is_on_ground(id))
	{
		client_print(id, 4, "You must stand on the ground to build a sentry gun!");
		return 0;
	}
	if (entity_get_int(id, 9))
	{
		client_print(id, 4, "Yeah, right, try building a sentry gun sitting on your ***!");
		return 0;
	}
	new Float:playerOrigin[3] = 0.0;
	entity_get_vector(id, PLUGINNAME, playerOrigin);
	new Float:vNewOrigin[3] = 0.0;
	new Float:vTraceDirection[3] = 0.0;
	new Float:vTraceEnd[3] = 0.0;
	new Float:vTraceResult[3] = 0.0;
	velocity_by_aim(id, 64, vTraceDirection);
	vTraceEnd[0] = floatadd(vTraceDirection[0], playerOrigin[0]);
	vTraceEnd[1] = floatadd(vTraceDirection[1], playerOrigin[1]);
	vTraceEnd[2] = floatadd(vTraceDirection[2], playerOrigin[2]);
	trace_line(id, playerOrigin, vTraceEnd, vTraceResult);
	vNewOrigin[0] = vTraceResult[0];
	vNewOrigin[1] = vTraceResult[1];
	vNewOrigin[2] = playerOrigin[2];
	if (CreateSentryBase(vNewOrigin, id))
	{
		cs_set_user_money(id, cs_get_user_money(id) - g_COST[0], 1);
	}
	else
	{
		client_print(id, 4, "Cannot build sentry here");
	}
	return 0;
}

GetSentryCount(id)
{
	return g_playerSentries[id + -1];
}

bool:GetStatusTrigger(player)
{
	if (!is_user_alive(player))
	{
		return false;
	}
	new var1;
	if (1 << player + -1 & g_sentryStatusTrigger)
	{
		var1 = true;
	}
	else
	{
		var1 = false;
	}
	return var1;
}

SetStatusTrigger(player, bool:onOrOff)
{
	if (onOrOff)
	{
		g_sentryStatusTrigger = 1 << player + -1 | g_sentryStatusTrigger;
	}
	else
	{
		g_sentryStatusTrigger = ~1 << player + -1 & g_sentryStatusTrigger;
	}
	return 0;
}

IncreaseSentryCount(id, sentryEntity)
{
	g_playerSentriesEdicts[id + -1][g_playerSentries[id + -1]] = sentryEntity;
	g_playerSentries[id + -1] = g_playerSentries[id + -1] + 1;
	new Float:sentryOrigin[3] = 0.0;
	new iSentryOrigin[3];
	entity_get_vector(sentryEntity, PLUGINNAME, sentryOrigin);
	FVecIVec(sentryOrigin, iSentryOrigin);
	new name[32];
	get_user_name(id, name, 31);
	new CsTeams:builderTeam = cs_get_user_team(id, 0);
	new i = 1;
	while (i <= g_MAXPLAYERS)
	{
		new var1;
		if (!is_user_connected(i) || !is_user_alive(i) || builderTeam == cs_get_user_team(i, 0) || i != id)
		{
		}
		else
		{
			client_print(i, 4, "%s has built a sentry gun %d units away from you", name, floatround(entity_range(i, sentryEntity), PLUGINNAME));
			message_begin(1, g_msgHostagePos, 37460, i);
			write_byte(i);
			write_byte(21);
			write_coord(iSentryOrigin[0]);
			write_coord(iSentryOrigin[1]);
			write_coord(iSentryOrigin[2]);
			message_end();
			message_begin(1, g_msgHostageK, 37472, i);
			write_byte(21);
			message_end();
		}
		i++;
	}
	return 0;
}

DecreaseSentryCount(id, sentry)
{
	g_selectedSentry[id + -1] = -1;
	new i;
	while (g_playerSentries[id + -1] > i)
	{
		if (sentry == g_playerSentriesEdicts[id + -1][i])
		{
			g_playerSentriesEdicts[id + -1][i] = g_playerSentriesEdicts[id + -1][g_playerSentries[id + -1] - 1];
			g_playerSentriesEdicts[id + -1][g_playerSentries[id + -1] - 1] = 0;
			g_playerSentries[id + -1] = g_playerSentries[id + -1] - 1;
			return 0;
		}
		i++;
	}
	g_playerSentries[id + -1] = g_playerSentries[id + -1] - 1;
	return 0;
}

bool:CreateSentryBase(Float:origin[3], creator)
{
	new var1;
	if (point_contents(origin) == -1 && TraceCheckCollides(origin, 24.0))
	{
		return false;
	}
	new Float:hitPoint[3] = 0.0;
	new Float:originDown[3] = 0.0;
	new var3 = origin;
	originDown = var3;
	originDown[2] = -5000.0;
	trace_line(PLUGINNAME, origin, originDown, hitPoint);
	new Float:baDistanceFromGround = vector_distance(origin, hitPoint);
	new Float:difference = floatsub(1108344832, baDistanceFromGround);
	new var2;
	if (difference < 1101004800 * -1 || difference > 20.0)
	{
		return false;
	}
	new entbase = create_entity("func_breakable");
	if (!entbase)
	{
		return false;
	}
	new hull = create_entity("func_wall");
	if (!hull)
	{
		return false;
	}
	new healthstring[16];
	num_to_str(floatround(g_HEALTHS[0], PLUGINNAME), healthstring, 15);
	DispatchKeyValue(entbase, "health", healthstring);
	DispatchKeyValue(entbase, "material", 37648);
	DispatchSpawn(entbase);
	entity_set_string(entbase, PLUGINNAME, "sentrybase");
	entity_set_string(hull, PLUGINNAME, "sentryhull");
	entity_set_model(entbase, "models/sentries/base.mdl");
	entity_set_model(hull, "models/sentries/base.mdl");
	entity_set_int(hull, 32, 1);
	entity_set_float(hull, 29, PLUGINNAME);
	entity_set_int(hull, 33, PLUGINNAME);
	new Float:mins[3] = 0.0;
	new Float:maxs[3] = 0.0;
	mins[0] = -17.0;
	mins[1] = -17.0;
	mins[2] = 0.0;
	maxs[0] = 17.0;
	maxs[1] = 17.0;
	maxs[2] = 1000.0;
	entity_set_size(entbase, mins, maxs);
	entity_set_origin(entbase, origin);
	entity_set_int(entbase, 15, "");
	entity_set_int(hull, 15, "");
	entity_set_int(entbase, 14, 6);
	entity_set_int(hull, 14, 6);
	entity_set_int(entbase, "", cs_get_user_team(creator, 0));
	entity_set_int(hull, "", cs_get_user_team(creator, 0));
	entity_set_edict(entbase, 9, creator);
	entity_set_edict(hull, 7, entbase);
	new parms[3];
	parms[2] = hull;
	parms[0] = entbase;
	parms[1] = creator;
	set_task(1073741824, "createsentryhead", PLUGINNAME, parms, "", 38012, PLUGINNAME);
	g_inBuilding[creator + -1] = 1;
	emit_sound(creator, PLUGINNAME, "sentries/building.wav", 1065353216, 1061997773, PLUGINNAME, AUTHOR);
	new Float:vector[3] = 0.0;
	vector[0] = 0.0;
	vector[1] = 0.0;
	vector[2] = 0.0;
	entity_set_vector(creator, 2, vector);
	return true;
}

public createsentryhead(parms[3])
{
	new entbase = parms[0];
	new creator = parms[1];
	new hull = parms[2];
	new var1;
	if (!g_inBuilding[creator + -1] || !is_user_alive(creator))
	{
		if (is_valid_ent(entbase))
		{
			remove_entity(entbase);
		}
		if (is_valid_ent(hull))
		{
			remove_entity(hull);
		}
		return 0;
	}
	new Float:origin[3] = 0.0;
	new var5 = g_sentryOrigins[creator + -1];
	origin = var5;
	new ent = create_entity("func_breakable");
	if (!ent)
	{
		if (is_valid_ent(entbase))
		{
			remove_entity(entbase);
		}
		if (is_valid_ent(hull))
		{
			remove_entity(hull);
		}
		return 0;
	}
	new Float:mins[3] = 0.0;
	new Float:maxs[3] = 0.0;
	decl bool:entbaseIsValid;
	new var2;
	if (is_valid_ent(entbase) == 1)
	{
		var2 = 1;
	}
	else
	{
		var2 = 0;
	}
	entbaseIsValid = var2;
	if (is_valid_ent(hull))
	{
		mins[0] = -16.1;
		mins[1] = -16.1;
		mins[2] = 0.0;
		maxs[0] = 16.1;
		maxs[1] = 16.1;
		maxs[2] = 16.1;
		entity_set_size(hull, mins, maxs);
		if (entbaseIsValid)
		{
			entity_set_edict(entbase, 8, hull);
			new Float:baseOrigin[3] = 0.0;
			entity_get_vector(entbase, PLUGINNAME, baseOrigin);
			entity_set_origin(hull, baseOrigin);
		}
	}
	if (entbaseIsValid)
	{
		mins[0] = -16.0;
		mins[1] = -16.0;
		mins[2] = 0.0;
		maxs[0] = 16.0;
		maxs[1] = 16.0;
		maxs[2] = 16.0;
		entity_set_size(entbase, mins, maxs);
		entity_set_edict(ent, 7, entbase);
		entity_set_edict(entbase, 7, ent);
	}
	g_sentries[g_sentriesNum] = ent;
	new healthstring[16];
	num_to_str(floatround(g_HEALTHS[0], PLUGINNAME), healthstring, 15);
	DispatchKeyValue(ent, "health", healthstring);
	DispatchKeyValue(ent, "material", 38228);
	DispatchSpawn(ent);
	entity_set_string(ent, PLUGINNAME, "sentry");
	entity_set_model(ent, "models/sentries/sentry1.mdl");
	mins[0] = -16.0;
	mins[1] = -16.0;
	mins[2] = 0.0;
	maxs[0] = 16.0;
	maxs[1] = 16.0;
	maxs[2] = 48.0;
	entity_set_size(ent, mins, maxs);
	entity_set_origin(ent, origin);
	entity_get_vector(creator, 6, origin);
	origin[0] = 0.0;
	new var6 = origin[1];
	var6 = floatadd(1127481344, var6);
	entity_set_float(ent, 33, origin[1]);
	origin[2] = 0.0;
	entity_set_vector(ent, 6, origin);
	entity_set_int(ent, 15, "");
	entity_set_int(ent, 14, 6);
	set_pev(ent, 107, 127);
	set_pev(ent, 108, 127);
	entity_set_float(ent, 36, 1123942400);
	set_pev(ent, 109, 127);
	SetSentryPeople(ent, 0, creator);
	SetSentryTeam(ent, cs_get_user_team(creator, 0));
	SetSentryLevel(ent, 0);
	decl topColor;
	new var3;
	if (cs_get_user_team(creator, 0) == 2)
	{
		var3 = 150;
	}
	else
	{
		var3 = 0;
	}
	topColor = var3;
	decl bottomColor;
	new var4;
	if (cs_get_user_team(creator, 0) == 2)
	{
		var4 = 160;
	}
	else
	{
		var4 = 0;
	}
	bottomColor = var4;
	new map = bottomColor << 8 | topColor;
	entity_set_int(ent, 28, map);
	g_sentriesNum += 1;
	emit_sound(ent, PLUGINNAME, "sentries/turrset.wav", 1065353216, 1061997773, PLUGINNAME, AUTHOR);
	IncreaseSentryCount(creator, ent);
	new parm[1];
	parm[0] = ent;
	set_task(g_THINKFREQUENCIES[0], "sentry_think", parm[0] + 4000, parm, 1, 38012, PLUGINNAME);
	new directions = random_num(PLUGINNAME, 1) << 1 | random_num(PLUGINNAME, 1) << 0;
	SetSentryPenddir(ent, directions);
	g_inBuilding[creator + -1] = 0;
	if (!entbaseIsValid)
	{
		SetSentryFiremode(ent, 2);
	}
	return 0;
}

public server_frame()
{
	g_gameTime = get_gametime();
	g_deltaTime = floatsub(g_gameTime, g_lastGameTime);
	new tempSentries[64];
	new Float:angles[3] = 0.0;
	new tempSentriesNum;
	new i;
	while (i < g_sentriesNum)
	{
		tempSentries[i] = g_sentries[i];
		tempSentriesNum++;
		i++;
	}
	new i;
	while (i < tempSentriesNum)
	{
		if (is_valid_ent(tempSentries[i]))
		{
			if (sentry_pendulum(tempSentries[i], g_deltaTime))
			{
				if (entity_get_edict(tempSentries[i], 8))
				{
					entity_get_vector(tempSentries[i], 6, angles);
					entity_set_vector(entity_get_edict(tempSentries[i], 8), 6, angles);
				}
			}
		}
		i++;
	}
	g_lastGameTime = g_gameTime;
	return 0;
}

bool:sentry_pendulum(sentry, Float:deltaTime)
{
	switch (GetSentryFiremode(sentry))
	{
		case 0:
		{
			new Float:angles[3] = 0.0;
			entity_get_vector(sentry, 6, angles);
			new Float:baseAngle = entity_get_float(sentry, 33);
			new directions = GetSentryPenddir(sentry);
			if (directions & 1)
			{
				new var5 = angles[1];
				var5 = floatsub(var5, floatmul(1092616192, deltaTime));
				if (angles[1] < floatsub(baseAngle, 1110704128))
				{
					angles[1] = floatsub(baseAngle, 1110704128);
					directions &= -2;
					SetSentryPenddir(sentry, directions);
				}
			}
			else
			{
				new var6 = angles[1];
				var6 = floatadd(var6, floatmul(1092616192, deltaTime));
				if (angles[1] > floatadd(1110704128, baseAngle))
				{
					angles[1] = floatadd(1110704128, baseAngle);
					directions |= 1;
					SetSentryPenddir(sentry, directions);
				}
			}
			entity_set_vector(sentry, 6, angles);
			if (GetSentryLevel(sentry) == 2)
			{
				new Float:radarAngle = entity_get_float(sentry, 36);
				if (directions & 2)
				{
					radarAngle = floatsub(radarAngle, 1069547520);
					if (radarAngle < 0.0)
					{
						radarAngle = 0.0;
						directions &= -3;
						SetSentryPenddir(sentry, directions);
					}
				}
				else
				{
					radarAngle = floatadd(1069547520, radarAngle);
					if (radarAngle > 255.0)
					{
						radarAngle = 255.0;
						directions |= 2;
						SetSentryPenddir(sentry, directions);
					}
				}
				entity_set_float(sentry, 36, radarAngle);
				set_pev(sentry, 109, floatround(radarAngle, PLUGINNAME));
			}
			return true;
		}
		case 2:
		{
			new Float:angles[3] = 0.0;
			entity_get_vector(sentry, 6, angles);
			new Float:spinSpeed = entity_get_float(sentry, 34);
			if (GetSentryPenddir(sentry) & 1)
			{
				new var1 = angles[1];
				var1 = floatsub(var1, floatmul(spinSpeed, deltaTime));
				if (angles[1] < 0.0)
				{
					angles[1] = floatadd(1135869952, angles[1]);
				}
			}
			else
			{
				new var2 = angles[1];
				var2 = floatadd(var2, floatmul(spinSpeed, deltaTime));
				if (angles[1] > 360.0)
				{
					angles[1] = floatsub(angles[1], 1135869952);
				}
			}
			new var3 = floatadd(spinSpeed, random_float(1065353216, 1073741824));
			spinSpeed = var3;
			entity_set_float(sentry, 34, var3);
			new Float:maxSpin = entity_get_float(sentry, 35);
			if (0.0 == maxSpin)
			{
				new var4 = random_float(1140457472, 1144750080);
				maxSpin = var4;
				entity_set_float(sentry, 35, var4);
			}
			else
			{
				if (spinSpeed >= maxSpin)
				{
					sentry_detonate(sentry, false, false);
					return false;
				}
			}
			entity_set_vector(sentry, 6, angles);
			return true;
		}
		default:
		{
			return true;
		}
	}
}

bool:TraceCheckCollides(Float:origin[3], Float:BOUNDS)
{
	new Float:traceEnds[8][3] = {
		{
			0, ...
		},
		{
			119, 101, 97
		},
		{
			112, 111, 110
		},
		{
			98, 111, 120
		},
		{
			0, 97, 114
		},
		{
			109, 111, 117
		},
		{
			114, 121, 95
		},
		{
			101, 110, 116
		}
	};
	new Float:traceHit[3] = 0.0;
	new hitEnt;
	traceEnds[0][traceEnds] = floatsub(origin[0], BOUNDS);
	traceEnds[0][traceEnds][1] = floatsub(origin[1], BOUNDS);
	traceEnds[0][traceEnds][2] = floatsub(origin[2], BOUNDS);
	traceEnds[1] = floatsub(origin[0], BOUNDS);
	traceEnds[1][1] = floatsub(origin[1], BOUNDS);
	traceEnds[1][2] = floatadd(origin[2], BOUNDS);
	traceEnds[2] = floatadd(origin[0], BOUNDS);
	traceEnds[2][1] = floatsub(origin[1], BOUNDS);
	traceEnds[2][2] = floatadd(origin[2], BOUNDS);
	traceEnds[3] = floatadd(origin[0], BOUNDS);
	traceEnds[3][1] = floatsub(origin[1], BOUNDS);
	traceEnds[3][2] = floatsub(origin[2], BOUNDS);
	traceEnds[4] = floatsub(origin[0], BOUNDS);
	traceEnds[4][1] = floatadd(origin[1], BOUNDS);
	traceEnds[4][2] = floatsub(origin[2], BOUNDS);
	traceEnds[5] = floatsub(origin[0], BOUNDS);
	traceEnds[5][1] = floatadd(origin[1], BOUNDS);
	traceEnds[5][2] = floatadd(origin[2], BOUNDS);
	traceEnds[6] = floatadd(origin[0], BOUNDS);
	traceEnds[6][1] = floatadd(origin[1], BOUNDS);
	traceEnds[6][2] = floatadd(origin[2], BOUNDS);
	traceEnds[7] = floatadd(origin[0], BOUNDS);
	traceEnds[7][1] = floatadd(origin[1], BOUNDS);
	traceEnds[7][2] = floatsub(origin[2], BOUNDS);
	new i;
	while (i < 8)
	{
		if (point_contents(traceEnds[i]) != -1)
		{
			return true;
		}
		hitEnt = trace_line(PLUGINNAME, origin, traceEnds[i], traceHit);
		if (hitEnt)
		{
			return true;
		}
		new j;
		while (j < 3)
		{
			if (traceEnds[i][j] != traceHit[j])
			{
				return true;
			}
			j++;
		}
		i++;
	}
	return false;
}

tracer(Float:start[3], Float:end[3])
{
	new start_[3];
	new end_[3];
	FVecIVec(start, start_);
	FVecIVec(end, end_);
	message_begin(PLUGINNAME, 23, 38544, PLUGINNAME);
	write_byte(6);
	write_coord(start_[0]);
	write_coord(start_[1]);
	write_coord(start_[2]);
	write_coord(end_[0]);
	write_coord(end_[1]);
	write_coord(end_[2]);
	message_end();
	return 0;
}

create_explosion(Float:origin_[3])
{
	new origin[3];
	FVecIVec(origin_, origin);
	message_begin(PLUGINNAME, 23, origin, PLUGINNAME);
	write_byte("");
	write_coord(origin[0]);
	write_coord(origin[1]);
	write_coord(origin[2]);
	write_short(g_sModelIndexFireball);
	write_byte(random_num(PLUGINNAME, 20) + 50);
	write_byte(12);
	write_byte(PLUGINNAME);
	message_end();
	genericShock(origin_, 250.0, "weaponbox", 32, 3.0, OBJECTTYPE:0);
	genericShock(origin_, 250.0, "armoury_entity", 32, 3.0, OBJECTTYPE:3);
	genericShock(origin_, 250.0, "player", 32, 3.0, OBJECTTYPE:2);
	genericShock(origin_, 250.0, "grenade", 32, 3.0, OBJECTTYPE:1);
	genericShock(origin_, 250.0, "hostage_entity", 32, 3.0, OBJECTTYPE:0);
	new Float:playerOrigin[3] = 0.0;
	new Float:distance = 0.0;
	new Float:flDmgToDo = 0.0;
	new Float:dmgbase = 0 + 90;
	new newHealth;
	new i = 1;
	while (i <= g_MAXPLAYERS)
	{
		new var1;
		if (!is_user_alive(i) || get_user_godmode(i))
		{
		}
		else
		{
			entity_get_vector(i, PLUGINNAME, playerOrigin);
			distance = vector_distance(playerOrigin, origin_);
			if (distance <= 250.0)
			{
				flDmgToDo = floatsub(dmgbase, floatmul(dmgbase, floatdiv(distance, 1132068864)));
				newHealth = get_user_health(i) - floatround(flDmgToDo, PLUGINNAME);
				if (0 >= newHealth)
				{
					set_task(PLUGINNAME, "TicketToHell", i, 38828, PLUGINNAME, 38012, PLUGINNAME);
				}
				set_user_health(i, newHealth);
				message_begin(8, g_msgDamage, 38832, i);
				write_byte(floatround(flDmgToDo, PLUGINNAME));
				write_byte(floatround(flDmgToDo, PLUGINNAME));
				write_long(64);
				write_coord(origin[0]);
				write_coord(origin[1]);
				write_coord(origin[2]);
				message_end();
			}
		}
		i++;
	}
	return 0;
}

public TicketToHell(player)
{
	if (!is_user_connected(player))
	{
		return 0;
	}
	new frags = get_user_frags(player);
	user_kill(player, 1);
	new parms[4];
	parms[0] = player;
	parms[1] = frags;
	parms[2] = cs_get_user_deaths(player);
	parms[3] = cs_get_user_team(player, 0);
	set_task(PLUGINNAME, "DelayedScoreInfoUpdate", PLUGINNAME, parms, 4, 38012, PLUGINNAME);
	return 0;
}

public DelayedScoreInfoUpdate(parms[4])
{
	scoreinfo_update(parms[0], parms[1], parms[2], parms[3]);
	return 0;
}


/* ERROR! null */
 function "genericShock" (number 38)

entity_is_on_ground(entity)
{
	return entity_get_int(entity, 27) & 512;
}

public message_tempentity()
{
	new var1;
	if (get_msg_args() != 15 && get_msg_arg_int(1) != 108)
	{
		return 0;
	}
	new i;
	while (i < g_sentriesNum)
	{
		if (entity_get_float(g_sentries[i], 13) <= 0)
		{
			sentry_detonate(i, false, true);
			i--;
		}
		i++;
	}
	return 0;
}

public think_sentrybase(sentrybase)
{
	sentrybase_broke(sentrybase);
	return 0;
}

sentrybase_broke(sentrybase)
{
	new hull = entity_get_edict(sentrybase, 8);
	new sentry = entity_get_edict(sentrybase, 7);
	if (is_valid_ent(sentrybase))
	{
		if (hull)
		{
			remove_entity(hull);
		}
		remove_entity(sentrybase);
	}
	if (sentry)
	{
		entity_set_edict(sentry, 7, PLUGINNAME);
		SetSentryFiremode(sentry, 2);
		set_pev(sentry, 107, 127);
		return 0;
	}
	return 0;
}

sentry_detonate(sentry, bool:quiet, bool:isIndex)
{
	new i;
	if (isIndex)
	{
		i = sentry;
		sentry = g_sentries[sentry];
		if (!is_valid_ent(sentry))
		{
			return 0;
		}
	}
	else
	{
		if (!is_valid_ent(sentry))
		{
			return 0;
		}
		new j;
		while (j < g_sentriesNum)
		{
			if (sentry == g_sentries[j])
			{
				i = j;
			}
			j++;
		}
	}
	remove_task(sentry + 4000, PLUGINNAME);
	remove_task(sentry + 5000, PLUGINNAME);
	remove_task(sentry + 6000, PLUGINNAME);
	new owner = GetSentryPeople(sentry, 0);
	if (entity_get_edict(sentry, 8))
	{
		remove_task(owner + 7000, PLUGINNAME);
		new parms[3];
		parms[0] = owner;
		parms[1] = entity_get_edict(sentry, 8);
		parms[2] = sentry;
		DestroySpyCam(parms);
	}
	if (!quiet)
	{
		new Float:origin[3] = 0.0;
		entity_get_vector(sentry, PLUGINNAME, origin);
		create_explosion(origin);
		client_print(owner, 4, "Your sentry gun detonated!");
	}
	DecreaseSentryCount(owner, sentry);
	if (GetSentryFiremode(sentry) != 2)
	{
		new base = entity_get_edict(sentry, 7);
		remove_entity(entity_get_edict(base, 8));
		remove_entity(base);
	}
	remove_entity(sentry);
	g_sentries[i] = g_sentries[g_sentriesNum + -1];
	g_sentriesNum -= 1;
	return 0;
}

sentry_detonate_by_owner(owner, bool:quiet)
{
	new i;
	while (i < g_sentriesNum)
	{
		if (owner == GetSentryPeople(g_sentries[i], 0))
		{
			sentry_detonate(i, quiet, true);
			return 0;
		}
		i++;
	}
	return 0;
}

public client_disconnect(id)
{
	while (0 < GetSentryCount(id))
	{
		sentry_detonate_by_owner(id, false);
	}
	return 0;
}

public sentry_think(parm[1])
{
	if (!is_valid_ent(parm[0]))
	{
		client_print(PLUGINNAME, "", "%d is not a valid ent, ending sentry_think!", parm);
		return 0;
	}
	new ent = parm[0];
	if (GetSentryTeam(ent) != cs_get_user_team(GetSentryPeople(ent, 0), 0))
	{
		client_disconnect(GetSentryPeople(ent, 0));
		return 0;
	}
	new Float:sentryOrigin[3] = 0.0;
	new Float:hitOrigin[3] = 0.0;
	new hitent;
	entity_get_vector(ent, PLUGINNAME, sentryOrigin);
	new var7 = sentryOrigin[2];
	var7 = floatadd(1101004800, var7);
	new target = GetSentryPeople(ent, 3);
	new firemode = GetSentryFiremode(ent);
	new var1;
	if (firemode == 1 && GetSentryTeam(ent) != cs_get_user_team(target, 0))
	{
		if (!is_user_alive(target))
		{
			SetSentryFiremode(ent, 0);
			goto Label_93F4;
		}
		new sentryLevel = GetSentryLevel(ent);
		new Float:targetOrigin[3] = 0.0;
		entity_get_vector(target, PLUGINNAME, targetOrigin);
		if (entity_get_int(target, 27) & 16384)
		{
			new var8 = targetOrigin[2];
			var8 = floatadd(1099956224, var8);
		}
		hitent = trace_line(ent, sentryOrigin, targetOrigin, hitOrigin);
		if (entity_get_edict(ent, 7) == hitent)
		{
			hitent = trace_line(hitent, hitOrigin, targetOrigin, hitOrigin);
		}
		new var2;
		if (target != hitent && is_user_alive(hitent) && cs_get_user_team(hitent, 0) != GetSentryTeam(ent))
		{
			target = hitent;
			SetSentryPeople(ent, 3, hitent);
		}
		if (target == hitent)
		{
			sentry_turntotarget(ent, sentryOrigin, target, targetOrigin);
			emit_sound(ent, 1, g_FIRESOUNDS[random_num(PLUGINNAME, 1)], 1065353216, 1061997773, PLUGINNAME, AUTHOR);
			new Float:hitRatio = floatsub(random_float(PLUGINNAME, 1065353216), g_HITRATIOS[sentryLevel]);
			new var3;
			if (!get_user_godmode(target) && hitRatio <= 0.0)
			{
				sentry_damagetoplayer(ent, sentryLevel, sentryOrigin, target);
			}
			else
			{
				new Float:sentryAngle[3] = 0.0;
				new Float:x = floatsub(hitOrigin[0], sentryOrigin[0]);
				new Float:z = floatsub(hitOrigin[1], sentryOrigin[1]);
				new Float:radians = floatatan(floatdiv(z, x), PLUGINNAME);
				sentryAngle[1] = floatmul(radians, g_ONEEIGHTYTHROUGHPI);
				if (hitOrigin[0] < sentryOrigin[0])
				{
					new var9 = sentryAngle[1];
					var9 = floatsub(var9, 1127481344);
				}
				new Float:h = floatsub(hitOrigin[2], sentryOrigin[2]);
				new Float:b = vector_distance(sentryOrigin, hitOrigin);
				radians = floatatan(floatdiv(h, b), PLUGINNAME);
				sentryAngle[0] = floatmul(radians, g_ONEEIGHTYTHROUGHPI);
				sentryAngle[0] = floatadd(sentryAngle[0], random_float(floatmul(-1054867456, hitRatio), floatmul(1092616192, hitRatio)));
				new var10 = sentryAngle[1];
				var10 = floatadd(var10, random_float(floatmul(-1054867456, hitRatio), floatmul(1092616192, hitRatio)));
				engfunc(17, sentryAngle);
				new Float:vector[3] = 0.0;
				get_global_vector(26, vector);
				new i;
				while (i < 3)
				{
					vector[i] *= 1000;
					i++;
				}
				new Float:traceEnd[3] = 0.0;
				new i;
				while (i < 3)
				{
					traceEnd[i] = floatadd(vector[i], sentryOrigin[i]);
					i++;
				}
				new hitEnt = ent;
				do {
				} while ((hitEnt = trace_line(hitEnt, hitOrigin, traceEnd, hitOrigin)));
			}
			tracer(sentryOrigin, hitOrigin);
			set_task(1036831949, "sentry_think", parm[0] + 4000, parm, 1, 38012, PLUGINNAME);
			return 0;
		}
		SetSentryFiremode(ent, 0);
	}
	else
	{
		if (firemode == 2)
		{
			new hitEnt = entityviewhitpoint(ent, sentryOrigin, hitOrigin);
			emit_sound(ent, 1, "weapons/m249-1.wav", 1065353216, 1061997773, PLUGINNAME, AUTHOR);
			tracer(sentryOrigin, hitOrigin);
			new var4;
			if (is_user_connected(hitEnt) && is_user_alive(hitEnt) && !get_user_godmode(hitEnt))
			{
				sentry_damagetoplayer(ent, GetSentryLevel(ent), sentryOrigin, hitEnt);
			}
			set_task(1036831949, "sentry_think", parm[0] + 4000, parm, 1, 38012, PLUGINNAME);
			return 0;
		}
	}
	if (10 > random_num(PLUGINNAME, ""))
	{
		emit_sound(ent, PLUGINNAME, "sentries/turridle.wav", 1065353216, 1061997773, PLUGINNAME, AUTHOR);
	}
	new closestTarget;
	new Float:closestDistance = 0.0;
	new Float:distance = 0.0;
	new Float:closestOrigin[3] = 0.0;
	new Float:playerOrigin[3] = 0.0;
	new CsTeams:sentryTeam = GetSentryTeam(ent);
	new i = 1;
	while (i <= g_MAXPLAYERS)
	{
		new var5;
		if (!is_user_connected(i) || !is_user_alive(i) || sentryTeam != cs_get_user_team(i, 0))
		{
		}
		else
		{
			entity_get_vector(i, PLUGINNAME, playerOrigin);
			if (entity_get_int(i, 27) & 16384)
			{
				new var11 = playerOrigin[2];
				var11 = floatadd(1099956224, var11);
			}
			hitent = trace_line(ent, sentryOrigin, playerOrigin, hitOrigin);
			if (entity_get_edict(ent, 7) == hitent)
			{
				hitent = trace_line(hitent, hitOrigin, playerOrigin, hitOrigin);
			}
			if (i == hitent)
			{
				distance = vector_distance(sentryOrigin, playerOrigin);
				closestOrigin = playerOrigin;
				new var6;
				if (distance < closestDistance || closestTarget)
				{
					closestTarget = i;
					closestDistance = distance;
				}
			}
		}
		i++;
	}
	if (closestTarget)
	{
		emit_sound(ent, PLUGINNAME, "sentries/turrspot.wav", 1065353216, 1061997773, PLUGINNAME, AUTHOR);
		sentry_turntotarget(ent, sentryOrigin, closestTarget, closestOrigin);
		SetSentryFiremode(ent, 1);
		SetSentryPeople(ent, 3, closestTarget);
		entity_set_float(ent, 36, 1123942400);
		set_pev(ent, 109, 127);
	}
	else
	{
		SetSentryFiremode(ent, 0);
	}
	Label_93F4:
	set_task(g_THINKFREQUENCIES[GetSentryLevel(ent)], "sentry_think", parm[0] + 4000, parm, 1, 38012, PLUGINNAME);
	return 0;
}

sentry_damagetoplayer(sentry, sentryLevel, Float:sentryOrigin[3], target)
{
	new newHealth = get_user_health(target) - g_DMG[sentryLevel];
	if (0 >= newHealth)
	{
		new targetFrags = get_user_frags(target) + 1;
		new owner = GetSentryPeople(sentry, 0);
		new ownerFrags = get_user_frags(owner) + 1;
		set_user_frags(target, targetFrags);
		set_user_frags(owner, ownerFrags);
		new contributors[3];
		new moneyRewards[33];
		contributors[0] = owner;
		contributors[1] = GetSentryPeople(sentry, 1);
		contributors[2] = GetSentryPeople(sentry, 2);
		new i;
		while (i <= sentryLevel)
		{
			new var2 = moneyRewards[contributors[i]];
			var2 = g_SENTRYFRAGREWARDS[i][var2];
			i++;
		}
		new i = 1;
		while (i <= g_MAXPLAYERS)
		{
			new var1;
			if (moneyRewards[i] && is_user_connected(i))
			{
				cs_set_user_money(i, moneyRewards[i][cs_get_user_money(i)], 1);
			}
			i++;
		}
		message_begin(2, g_msgDeathMsg, 39692, PLUGINNAME);
		write_byte(owner);
		write_byte(target);
		write_byte(PLUGINNAME);
		write_string("sentry gun");
		message_end();
		scoreinfo_update(owner, ownerFrags, cs_get_user_deaths(owner), cs_get_user_team(owner, 0));
		set_msg_block(g_msgDeathMsg, 1);
		set_user_health(target, newHealth);
		return 0;
	}
	set_user_health(target, newHealth);
	message_begin(8, g_msgDamage, 39748, target);
	write_byte(g_DMG[sentryLevel]);
	write_byte(g_DMG[sentryLevel]);
	write_long(2);
	write_coord(floatround(sentryOrigin[0], PLUGINNAME));
	write_coord(floatround(sentryOrigin[1], PLUGINNAME));
	write_coord(floatround(sentryOrigin[2], PLUGINNAME));
	message_end();
	return 0;
}

scoreinfo_update(id, frags, deaths, team)
{
	message_begin(2, g_msgScoreInfo, 38544, PLUGINNAME);
	write_byte(id);
	write_short(frags);
	write_short(deaths);
	write_short(PLUGINNAME);
	write_short(team);
	message_end();
	return 0;
}

sentry_turntotarget(ent, Float:sentryOrigin[3], target, Float:closestOrigin[3])
{
	if (target)
	{
		new name[32];
		get_user_name(target, name, 31);
		new Float:newAngle[3] = 0.0;
		entity_get_vector(ent, 6, newAngle);
		new Float:x = floatsub(closestOrigin[0], sentryOrigin[0]);
		new Float:z = floatsub(closestOrigin[1], sentryOrigin[1]);
		new Float:radians = floatatan(floatdiv(z, x), PLUGINNAME);
		newAngle[1] = floatmul(radians, g_ONEEIGHTYTHROUGHPI);
		if (closestOrigin[0] < sentryOrigin[0])
		{
			new var1 = newAngle[1];
			var1 = floatsub(var1, 1127481344);
		}
		entity_set_float(ent, 33, newAngle[1]);
		new Float:h = floatsub(closestOrigin[2], sentryOrigin[2]);
		new Float:b = vector_distance(sentryOrigin, closestOrigin);
		radians = floatatan(floatdiv(h, b), PLUGINNAME);
		new Float:degs = floatmul(radians, g_ONEEIGHTYTHROUGHPI);
		new Float:RADIUS = 830.0;
		new Float:degreeByte = floatdiv(RADIUS, 1132462080);
		new Float:tilt = floatsub(1123942400, floatmul(degreeByte, degs));
		set_pev(ent, 107, floatround(tilt, PLUGINNAME));
		entity_set_vector(ent, 6, newAngle);
	}
	return 0;
}

public menumain(id)
{
	if (!is_user_alive(id))
	{
		return 1;
	}
	menumain_starter(id);
	return 1;
}

AimingAtSentry(id, bool:alwaysReturn)
{
	new hitEnt;
	new bodyPart;
	if (0 == get_user_aiming(id, hitEnt, bodyPart, 9999))
	{
		return 0;
	}
	new sentry;
	if (hitEnt)
	{
		new classname[32];
		new l_sentry;
		entity_get_string(hitEnt, PLUGINNAME, classname, 31);
		if (equal(classname, "sentrybase", PLUGINNAME))
		{
			l_sentry = entity_get_edict(hitEnt, 7);
		}
		else
		{
			if (equal(classname, "sentry", PLUGINNAME))
			{
				l_sentry = hitEnt;
			}
			if (equal(classname, "sentryhull", PLUGINNAME))
			{
				l_sentry = entity_get_edict(entity_get_edict(hitEnt, 7), 7);
			}
		}
		if (alwaysReturn)
		{
			return l_sentry;
		}
		new sentryLevel = GetSentryLevel(l_sentry);
		new owner = GetSentryPeople(l_sentry, 0);
		new var1;
		if (cs_get_user_team(id, 0) == cs_get_user_team(owner, 0) && sentryLevel < 2)
		{
			new var2;
			if (!(sentryLevel && owner == id))
			{
				new var3;
				if (!(sentryLevel == 1 && GetSentryPeople(l_sentry, 1) == id))
				{
					sentry = l_sentry;
				}
			}
		}
	}
	return sentry;
}

menumain_starter(id)
{
	if (g_inSpyCam[id + -1])
	{
		return 0;
	}
	g_aimSentry[id + -1] = 0;
	new menuBuffer[256];
	new len;
	new flags = 512;
	len = format(menuBuffer[len], 255 - len, "\ySentry gun menu\n\n") + len;
	new var1;
	if (GetSentryCount(id) < 2 && cs_get_user_money(id) >= g_COST[0])
	{
		var2 = 40052;
	}
	else
	{
		var2 = 40064;
	}
	len = format(menuBuffer[len], 255 - len, "%s1. Build sentry, $%d\n", var2, g_COST) + len;
	new var3;
	if (GetSentryCount(id) > 0 && g_selectedSentry[id + -1] == -1)
	{
		g_selectedSentry[id + -1] = g_playerSentriesEdicts[id + -1][0];
	}
	if (g_selectedSentry[id + -1])
	{
		new parm[2];
		parm[0] = id;
		parm[1] = g_selectedSentry[id + -1];
		set_task(PLUGINNAME, "SentryRadarBlink", g_selectedSentry[id + -1][1500], parm, 2, 38012, PLUGINNAME);
	}
	new var4;
	if (GetSentryCount(id) > 0)
	{
		var4 = 40304;
	}
	else
	{
		var4 = 40316;
	}
	len = format(menuBuffer[len], 255 - len, "%s2. Detonate sentry flashing on radar\n", var4) + len;
	if (len)
	{
		new sentry = AimingAtSentry(id, false);
		if (sentry)
		{
			new sentryLevel = GetSentryLevel(sentry);
			if (entity_range(sentry, id) <= 1117126656)
			{
				if (g_COST[sentryLevel + 1] <= cs_get_user_money(id))
				{
					len = format(menuBuffer[len], 255 - len, "\w3. Upgrade this sentry, $%d\n", g_COST[sentryLevel + 1]) + len;
					flags |= 4;
					g_aimSentry[id + -1] = sentry;
				}
				else
				{
					len = format(menuBuffer[len], 255 - len, "\d3. Upgrade this sentry (needs $%d)\n", g_COST[sentryLevel + 1]) + len;
				}
			}
			else
			{
				len = format(menuBuffer[len], 255 - len, "\d3. Upgrade this sentry, $%d (out of range)\n", g_COST[sentryLevel + 1]) + len;
			}
		}
	}
	if (1 < GetSentryCount(id))
	{
		len = format(menuBuffer[len], 255 - len, "\w4. Detonate all sentries\n") + len;
		len = format(menuBuffer[len], 255 - len, "\n\w5. Select previous sentry\n") + len;
		len = format(menuBuffer[len], 255 - len, "\w6. Select next sentry\n") + len;
		flags |= 56;
	}
	new var5;
	if (g_selectedSentry[id + -1] != -1)
	{
		var5 = 41284;
	}
	else
	{
		var5 = 41296;
	}
	len = format(menuBuffer[len], 255 - len, "%s7. View from sentry flashing on radar\n", var5) + len;
	if (g_selectedSentry[id + -1] != -1)
	{
		flags |= 64;
	}
	len = format(menuBuffer[len], 255 - len, "\n\w0. Exit") + len;
	if (0 < GetSentryCount(id))
	{
		flags |= 2;
	}
	new var6;
	if (GetSentryCount(id) < 2 && cs_get_user_money(id) >= g_COST[0])
	{
		flags |= 1;
	}
	show_menu(id, flags, menuBuffer, -1, 41352);
	return 0;
}

public SentryRadarBlink(parm[2])
{
	new var1;
	if (!is_user_connected(parm[0]) || !is_valid_ent(parm[1]))
	{
		return 0;
	}
	new Float:sentryOrigin[3] = 0.0;
	entity_get_vector(parm[1], PLUGINNAME, sentryOrigin);
	message_begin(1, g_msgHostagePos, 41356, parm[0]);
	write_byte(parm[0]);
	write_byte(20);
	write_coord(floatround(sentryOrigin[0], PLUGINNAME));
	write_coord(floatround(sentryOrigin[1], PLUGINNAME));
	write_coord(floatround(sentryOrigin[2], PLUGINNAME));
	message_end();
	message_begin(1, g_msgHostageK, 41368, parm[0]);
	write_byte(20);
	message_end();
	new usermenuid;
	new keys;
	get_user_menu(parm[0], usermenuid, keys);
	if (usermenuid == g_menuId)
	{
		set_task(1069547520, "SentryRadarBlink", parm[1] + 6000, parm, 2, 38012, PLUGINNAME);
	}
	return 0;
}

public menumain_handle(id, key)
{
	new bool:stayInMenu;
	switch (key)
	{
		case 0:
		{
			if (2 > GetSentryCount(id))
			{
				sentry_build(id);
			}
		}
		case 1:
		{
			new sentryCount = GetSentryCount(id);
			if (sentryCount == 1)
			{
				sentry_detonate_by_owner(id, false);
			}
			else
			{
				if (sentryCount > 1)
				{
					sentry_detonate(g_selectedSentry[id + -1], false, false);
				}
			}
		}
		case 2:
		{
			new sentry = g_aimSentry[id + -1];
			new var1;
			if (is_valid_ent(sentry) && entity_range(sentry, id) <= 1117126656)
			{
				sentry_upgrade(id, sentry);
			}
		}
		case 3:
		{
			while (0 < GetSentryCount(id))
			{
				sentry_detonate_by_owner(id, false);
			}
		}
		case 4:
		{
			CycleSelectedSentry(id, -1);
			stayInMenu = true;
		}
		case 5:
		{
			CycleSelectedSentry(id, 1);
			stayInMenu = true;
		}
		case 6:
		{
			if (g_selectedSentry[id + -1] != -1)
			{
				new spycam = CreateSpyCam(id, g_selectedSentry[id + -1]);
				if (!spycam)
				{
					return 1;
				}
				new parms[3];
				parms[0] = id;
				parms[1] = spycam;
				parms[2] = g_selectedSentry[id + -1];
				set_task(1084227584, "DestroySpyCam", id + 7000, parms, "", 38012, PLUGINNAME);
			}
		}
		case 9:
		{
		}
		default:
		{
		}
	}
	if (stayInMenu)
	{
		menumain_starter(id);
	}
	return 1;
}

CreateSpyCam(id, sentry)
{
	new spycam = create_entity("info_target");
	if (!spycam)
	{
		return 0;
	}
	entity_set_edict(sentry, 8, spycam);
	entity_set_string(spycam, PLUGINNAME, "spycam");
	new Float:origin[3] = 0.0;
	entity_get_vector(sentry, PLUGINNAME, origin);
	new var1 = origin[2];
	var1 = floatadd(var1, g_spyCamOffset[GetSentryLevel(sentry)]);
	entity_set_vector(spycam, PLUGINNAME, origin);
	entity_set_model(spycam, "models/sentries/base.mdl");
	entity_set_int(spycam, 32, 1);
	entity_set_float(spycam, 29, PLUGINNAME);
	entity_set_int(spycam, 33, PLUGINNAME);
	new Float:angles[3] = 0.0;
	entity_get_vector(sentry, 6, angles);
	entity_set_vector(spycam, 6, angles);
	engfunc(VERSION, id, spycam);
	g_inSpyCam[id + -1] = 1;
	return spycam;
}

public DestroySpyCam(parms[3])
{
	new id = parms[0];
	new spycam = parms[1];
	new sentry = parms[2];
	g_inSpyCam[id + -1] = 0;
	if (is_user_connected(id))
	{
		engfunc(VERSION, id, id);
	}
	new var1;
	if (is_valid_ent(sentry) && spycam == entity_get_edict(sentry, 8))
	{
		entity_set_edict(sentry, 8, PLUGINNAME);
	}
	remove_entity(spycam);
	return 0;
}

CycleSelectedSentry(id, steps)
{
	new index = -1;
	new i;
	while (g_playerSentries[id + -1] > i)
	{
		if (g_selectedSentry[id + -1] == g_playerSentriesEdicts[id + -1][i])
		{
			index = i;
			if (index == -1)
			{
				return 0;
			}
			remove_task(g_selectedSentry[id + -1][1500], PLUGINNAME);
			if (0 < steps)
			{
				do {
					index++;
					steps--;
					if (g_playerSentries[id + -1] == index)
					{
						index = 0;
					}
				} while (0 < steps);
			}
			else
			{
				if (0 > steps)
				{
					do {
						index--;
						steps++;
						if (index == -1)
						{
							index = g_playerSentries[id + -1] - 1;
						}
					} while (0 > steps);
				}
			}
			g_selectedSentry[id + -1] = g_playerSentriesEdicts[id + -1][index];
			return 0;
		}
		i++;
	}
	if (index == -1)
	{
		return 0;
	}
	remove_task(g_selectedSentry[id + -1][1500], PLUGINNAME);
	if (0 < steps)
	{
		do {
			index++;
			steps--;
			if (g_playerSentries[id + -1] == index)
			{
				index = 0;
			}
		} while (0 < steps);
	}
	else
	{
		if (0 > steps)
		{
			do {
				index--;
				steps++;
				if (index == -1)
				{
					index = g_playerSentries[id + -1] - 1;
				}
			} while (0 > steps);
		}
	}
	g_selectedSentry[id + -1] = g_playerSentriesEdicts[id + -1][index];
	return 0;
}

sentry_upgrade(id, sentry)
{
	new sentryLevel = GetSentryLevel(sentry);
	if (GetSentryFiremode(sentry) == 2)
	{
		client_print(id, 4, "This sentry cannot be upgraded.");
		return 0;
	}
	if (GetSentryTeam(sentry) != cs_get_user_team(id, 0))
	{
		client_print(id, 4, "You can only upgrade your own team's sentries.");
		return 0;
	}
	new var1;
	if (sentryLevel && id == GetSentryPeople(sentry, 0))
	{
		return 0;
	}
	new var2;
	if (sentryLevel == 1 && id == GetSentryPeople(sentry, 1))
	{
		return 0;
	}
	sentryLevel++;
	new bool:newLevelIsOK = 1;
	new upgraderField;
	switch (sentryLevel)
	{
		case 1:
		{
			entity_set_model(sentry, "models/sentries/sentry2.mdl");
			upgraderField = 1;
		}
		case 2:
		{
			entity_set_model(sentry, "models/sentries/sentry3.mdl");
			upgraderField = 2;
		}
		default:
		{
			newLevelIsOK = false;
		}
	}
	if (newLevelIsOK)
	{
		if (0 > cs_get_user_money(id) - g_COST[sentryLevel])
		{
			client_print(id, 4, "You don't have enough money to upgrade this sentry gun! (needed $%d)", g_COST[sentryLevel]);
			return 0;
		}
		cs_set_user_money(id, cs_get_user_money(id) - g_COST[sentryLevel], 1);
		new Float:mins[3] = 0.0;
		new Float:maxs[3] = 0.0;
		mins[0] = -16.0;
		mins[1] = -16.0;
		mins[2] = 0.0;
		maxs[0] = 16.0;
		maxs[1] = 16.0;
		maxs[2] = 48.0;
		entity_set_size(sentry, mins, maxs);
		emit_sound(sentry, PLUGINNAME, "sentries/turrset.wav", 1065353216, 1061997773, PLUGINNAME, AUTHOR);
		SetSentryLevel(sentry, sentryLevel);
		entity_set_float(sentry, 13, g_HEALTHS[sentryLevel]);
		entity_set_float(entity_get_edict(sentry, 7), 13, g_HEALTHS[0]);
		SetSentryPeople(sentry, upgraderField, id);
		if (GetSentryPeople(sentry, 0) != id)
		{
			new upgraderName[32];
			get_user_name(id, upgraderName, 31);
			client_print(GetSentryPeople(sentry, 0), 4, "%s upgraded your sentry gun to level %d", upgraderName, sentryLevel + 1);
		}
	}
	return 0;
}

entityviewhitpoint(index, Float:origin[3], Float:hitorigin[3])
{
	if (!is_valid_ent(index))
	{
		log_amx("ERROR in plugin - %d is not a valid entity index", index);
		return 0;
	}
	new Float:angle[3] = 0.0;
	new Float:vec[3] = 0.0;
	new Float:f_dest[3] = 0.0;
	entity_get_vector(index, 6, angle);
	engfunc(18, angle, vec, 0, 0);
	f_dest[0] = floatadd(origin[0], vec[0] * 9999);
	f_dest[1] = floatadd(origin[1], vec[1] * 9999);
	f_dest[2] = floatadd(origin[2], vec[2] * 9999);
	return trace_line(index, origin, f_dest, hitorigin);
}

public newround_event(id)
{
	g_inBuilding[id + -1] = 0;
	while (0 < GetSentryCount(id))
	{
		sentry_detonate_by_owner(id, true);
	}
	new var1;
	if (!g_resetArmouryThisRound && g_hasArmouries)
	{
		ResetArmoury();
		g_resetArmouryThisRound = true;
	}
	return 0;
}

public endround_event()
{
	if (!g_hasArmouries)
	{
		return 0;
	}
	set_task(1082130432, "ResetArmouryFalse", PLUGINNAME, 38828, PLUGINNAME, 38012, PLUGINNAME);
	return 0;
}

public ResetArmouryFalse()
{
	g_resetArmouryThisRound = false;
	return 0;
}

public client_putinserver(id)
{
	if (is_user_bot(id))
	{
		new parm[1];
		parm[0] = id;
		botbuildsrandomly(parm);
	}
	else
	{
		set_task(1097859072, "dispInfo", id, 38828, PLUGINNAME, 38012, PLUGINNAME);
	}
	return 0;
}

public dispInfo(id)
{
	client_print(id, "", "In this server you can build sentries! For help on how to bind the necessary buttons, say 'sentryhelp'!");
	return 0;
}

public check_say(id)
{
	new said[32];
	read_args(said, 31);
	new var1;
	if (equali(said, "\"sentryhelp\"", PLUGINNAME) || equali(said, "\"/sentryhelp\"", PLUGINNAME))
	{
		new msg[1537];
		new len = format(msg[len], 1536 - len, "<html><body>") + len;
		len = format(msg[len], 1536 - len, "<p>Sentries in TFC were cool. Sentries in CS are cool.<br/>") + len;
		len = format(msg[len], 1536 - len, "Sentry guns are stationary engineering wonders that fire bullets at and kill your enemies.<br/>") + len;
		len = format(msg[len], 1536 - len, "Sentry guns can be upgraded twice, with the help of a team member, to be bigger and meaner.</p>") + len;
		len = format(msg[len], 1536 - len, "<p>Open console and type \"bind j sentry_menu\" to bind the menu button to J. You can also bind \"sentry_build\".<br/>") + len;
		len = format(msg[len], 1536 - len, "Note that you can bind to any button you choose. To bind the fast build/update command to a mouse button 4, write \"bind mouse4 sentry_build\".</p>") + len;
		len = format(msg[len], 1536 - len, "<p>You <b>cannot</b> upgrade your own sentry from level 1 to level 2. A team mate must do this.</p>") + len;
		len = format(msg[len], 1536 - len, "<p>A sentry at level 2 <b>cannot</b> be upgraded to level 3 by the same player that performed the first upgrade. A team mate must do this (original builder is OK).</p>") + len;
		len = format(msg[len], 1536 - len, "<center>") + len;
		len = format(msg[len], 1536 - len, "<table width=\"50%\" border=\"1\">") + len;
		len = format(msg[len], 1536 - len, "<tr><td><b>Command</b></td><td><b>Description</b></td>") + len;
		len = format(msg[len], 1536 - len, "<tr><td>sentry_menu</td><td>From this menu you can build, upgrade and detonate sentry guns. To upgrade a sentry, first point at it, then open menu.</td>") + len;
		len = format(msg[len], 1536 - len, "<tr><td>sentry_build</td><td>Quick button to build and upgrade sentry guns. To upgrade a sentry, first point at it, then press this button.</td>") + len;
		len = format(msg[len], 1536 - len, "</table>") + len;
		len = format(msg[len], 1536 - len, "<table width=\"50%\" border=\"1\">") + len;
		len = format(msg[len], 1536 - len, "<tr><td><b>Sentry gun level</b></td><td><b>Cost to build/upgrade to</b></td>") + len;
		len = format(msg[len], 1536 - len, "<tr><td>1</td><td>%d</td>", g_COST) + len;
		len = format(msg[len], 1536 - len, "<tr><td>2</td><td>%d</td>", 180 + 4) + len;
		len = format(msg[len], 1536 - len, "<tr><td>3</td><td>%d</td>", 180 + 8) + len;
		len = format(msg[len], 1536 - len, "</table>") + len;
		len = format(msg[len], 1536 - len, "</center>") + len;
		len = format(msg[len], 1536 - len, "</body></html>") + len;
		show_motd(id, msg, "Sentry guns help");
	}
	else
	{
		if (containi(said, "sentr") != -1)
		{
			dispInfo(id);
		}
	}
	return 0;
}

public plugin_modules()
{
	require_module("engine");
	require_module("fun");
	require_module("cstrike");
	require_module("fakemeta");
	return 0;
}

public plugin_precache()
{
	precache_model("models/sentries/base.mdl");
	precache_model("models/sentries/sentry1.mdl");
	precache_model("models/sentries/sentry2.mdl");
	precache_model("models/sentries/sentry3.mdl");
	g_sModelIndexFireball = precache_model("sprites/zerogxplode.spr");
	precache_sound("debris/bustmetal1.wav");
	precache_sound("debris/bustmetal2.wav");
	precache_sound("debris/metal1.wav");
	precache_sound("debris/metal3.wav");
	precache_model("models/computergibs.mdl");
	precache_sound("sentries/asscan1.wav");
	precache_sound("sentries/asscan2.wav");
	precache_sound("sentries/asscan3.wav");
	precache_sound("sentries/asscan4.wav");
	precache_sound("sentries/turridle.wav");
	precache_sound("sentries/turrset.wav");
	precache_sound("sentries/turrspot.wav");
	precache_sound("sentries/building.wav");
	new var1 = g_FIRESOUNDS;
	precache_sound(var1[0][var1]);
	precache_sound(g_FIRESOUNDS[1]);
	return 0;
}

public forward_traceline_post(Float:start[3], Float:end[3], noMonsters, player)
{
	new var1;
	if (is_user_bot(player) || player < 1 || player > g_MAXPLAYERS)
	{
		return 1;
	}
	if (!is_user_alive(player))
	{
		return 1;
	}
	SetStatusTrigger(player, false);
	new hitEnt = get_tr(8);
	if (hitEnt <= g_MAXPLAYERS)
	{
		return 1;
	}
	new classname[11];
	new sentry;
	new base;
	new hull;
	entity_get_string(hitEnt, PLUGINNAME, classname, 10);
	if (equal(classname, "sentryhull", PLUGINNAME))
	{
		hull = hitEnt;
		base = entity_get_edict(hull, 7);
		sentry = entity_get_edict(base, 7);
	}
	else
	{
		if (equal(classname, "sentrybase", PLUGINNAME))
		{
			base = hitEnt;
			sentry = entity_get_edict(base, 7);
		}
		if (equal(classname, "sentry", PLUGINNAME))
		{
			sentry = hitEnt;
			base = entity_get_edict(sentry, 7);
		}
	}
	if (base)
	{
		if (cs_get_user_team(player, 0) == entity_get_int(base, ""))
		{
			if (player != entity_get_edict(base, 9))
			{
				entity_set_edict(base, 4, player);
			}
		}
	}
	new var2;
	if (!sentry || !base || GetSentryFiremode(sentry) == 2)
	{
		return 1;
	}
	new Float:health = entity_get_float(sentry, 13);
	if (health <= 0.0)
	{
		return 1;
	}
	new Float:basehealth = entity_get_float(base, 13);
	if (basehealth <= 0.0)
	{
		return 1;
	}
	new CsTeams:team = GetSentryTeam(sentry);
	if (cs_get_user_team(player, 0) != team)
	{
		return 1;
	}
	if (player != GetSentryPeople(sentry, 0))
	{
		entity_set_edict(sentry, 4, player);
		entity_set_edict(base, 4, player);
	}
	new level = GetSentryLevel(sentry);
	new upgradeInfo[128];
	if (PlayerCanUpgradeSentry(player, sentry))
	{
		format(upgradeInfo, 127, "\n(Run into me to upgrade me to level %d for $%d)", level + 2, g_COST[level + 1]);
	}
	else
	{
		if (level < 2)
		{
			format(upgradeInfo, 127, "\n(Upgrade cost: $%d)", g_COST[level + 1]);
		}
		upgradeInfo = {0};
	}
	new tempStatusBuffer[256];
	format(tempStatusBuffer, 255, "Health: %d/%d\nBase health: %d/%d\nLevel: %d%s", floatround(health, PLUGINNAME), floatround(g_HEALTHS[level], PLUGINNAME), floatround(basehealth, PLUGINNAME), floatround(g_HEALTHS[0], PLUGINNAME), level + 1, upgradeInfo);
	SetStatusTrigger(player, true);
	new var3;
	if (!task_exists(player + 3000, PLUGINNAME) || !equal(tempStatusBuffer, g_sentryStatusBuffer[player + -1], PLUGINNAME))
	{
		remove_task(player + 3000, PLUGINNAME);
		new parms[2];
		parms[0] = player;
		parms[1] = team;
		set_task(PLUGINNAME, "displaysentrystatus", player + 3000, parms, 2, 38012, PLUGINNAME);
	}
	return 1;
}

bool:PlayerCanUpgradeSentry(player, sentry)
{
	if (GetSentryFiremode(sentry) == 2)
	{
		return false;
	}
	new level = GetSentryLevel(sentry);
	switch (level)
	{
		case 0:
		{
			if (GetSentryPeople(sentry, 0) == player)
			{
				return false;
			}
			new var2;
			return GetSentryTeam(sentry) == cs_get_user_team(player, 0) && cs_get_user_money(player) >= g_COST[level + 1];
		}
		case 1:
		{
			if (GetSentryPeople(sentry, 1) == player)
			{
				return false;
			}
			new var1;
			return GetSentryTeam(sentry) == cs_get_user_team(player, 0) && cs_get_user_money(player) >= g_COST[level + 1];
		}
		default:
		{
			return false;
		}
	}
}

public displaysentrystatus(parms[2])
{
	if (!GetStatusTrigger(parms[0]))
	{
		return 0;
	}
	new var1;
	if (parms[1] == 2)
	{
		var1 = 150;
	}
	else
	{
		var1 = 0;
	}
	new var2;
	if (parms[1] == 1)
	{
		var2 = 150;
	}
	else
	{
		var2 = 0;
	}
	set_hudmessage(var2, PLUGINNAME, var1, -1082130432, 1051931443, PLUGINNAME, PLUGINNAME, floatadd(1056964608, 1036831949), PLUGINNAME, PLUGINNAME, 2);
	show_hudmessage(parms[0], g_sentryStatusBuffer[parms[0] - 1]);
	set_task(1056964608, "displaysentrystatus", parms[0] + 3000, parms, 2, 38012, PLUGINNAME);
	return 0;
}

ResetArmoury()
{
	new entity;
	new Float:NULLVELOCITY[3] = 0.0;
	new Float:origin[3] = 0.0;
	while ((entity = find_ent_by_class(entity, "armoury_entity")))
	{
		entity_set_vector(entity, 2, NULLVELOCITY);
		entity_get_vector(entity, 19, origin);
		entity_set_origin(entity, origin);
	}
	return 0;
}

public InitArmoury()
{
	new entity;
	new Float:origin[3] = 0.0;
	new counter;
	while ((entity = find_ent_by_class(entity, "armoury_entity")))
	{
		entity_get_vector(entity, PLUGINNAME, origin);
		entity_set_vector(entity, 19, origin);
		counter++;
	}
	if (0 < counter)
	{
		g_hasArmouries = true;
	}
	return 0;
}

getnumbers(number, wordnumbers[], length)
{
	if (0 > number)
	{
		format(wordnumbers, length, "error");
		return 0;
	}
	new numberstr[20];
	num_to_str(number, numberstr, 19);
	new stlen = strlen(numberstr);
	new bool:getzero;
	new bool:jumpnext;
	if (stlen == 1)
	{
		getzero = true;
	}
	do {
		if (jumpnext)
		{
			jumpnext = false;
		}
		else
		{
			if (numberstr[0] != 48)
			{
				switch (stlen)
				{
					case 1:
					{
						getsingledigit(numberstr, wordnumbers, length, getzero);
						if (wordnumbers[0] == 32)
						{
							jghg_trim(wordnumbers, length, 1, true);
						}
						return 0;
					}
					case 2:
					{
						jumpnext = gettens(wordnumbers, length, numberstr);
					}
					case 3:
					{
						getsingledigit(numberstr, wordnumbers, length, false);
						format(wordnumbers, length, "%s hundred", wordnumbers);
					}
					case 4:
					{
						getsingledigit(numberstr, wordnumbers, length, false);
						format(wordnumbers, length, "%s thousand", wordnumbers);
					}
					case 5:
					{
						jumpnext = gettens(wordnumbers, length, numberstr);
						new var5;
						if (numberstr[0] == 49 || numberstr[1] == 48)
						{
							format(wordnumbers, length, "%s thousand", wordnumbers);
						}
					}
					case 6:
					{
						if (getsingledigit(numberstr, wordnumbers, length, false))
						{
							new var3;
							if (numberstr[1] == 48 && numberstr[2] == 48)
							{
								var4 = 52184;
							}
							else
							{
								var4 = 52224;
							}
							format(wordnumbers, length, "%s hundred%s", wordnumbers, var4);
						}
					}
					case 7:
					{
						getsingledigit(numberstr, wordnumbers, length, false);
						format(wordnumbers, length, "%s million", wordnumbers);
					}
					case 8:
					{
						jumpnext = gettens(wordnumbers, length, numberstr);
						if (jumpnext)
						{
							format(wordnumbers, length, "%s million", wordnumbers);
						}
					}
					case 9:
					{
						if (getsingledigit(numberstr, wordnumbers, length, false))
						{
							new var1;
							if (numberstr[1] == 48 && numberstr[2] == 48)
							{
								var2 = 52004;
							}
							else
							{
								var2 = 52040;
							}
							format(wordnumbers, length, "%s hundred%s", wordnumbers, var2);
						}
					}
					default:
					{
						format(wordnumbers, length, "%s TOO LONG", wordnumbers);
						if (wordnumbers[0] == 32)
						{
							jghg_trim(wordnumbers, length, 1, true);
						}
						return 0;
					}
				}
			}
		}
		jghg_trim(numberstr, length, 1, true);
		stlen = strlen(numberstr);
	} while (0 < stlen);
	if (wordnumbers[0] == 32)
	{
		jghg_trim(wordnumbers, length, 1, true);
	}
	return 0;
}

bool:gettens(wordnumbers[], length, numberstr[])
{
	new digitstr[11];
	new bool:dont;
	new bool:jumpnext;
	switch (numberstr[0])
	{
		case 48:
		{
			dont = true;
		}
		case 49:
		{
			jumpnext = true;
			switch (numberstr[1])
			{
				case 48:
				{
					digitstr = {116,101,110,0};
				}
				case 49:
				{
					digitstr = {101,108,101,118,101,110,0};
				}
				case 50:
				{
					digitstr = {116,119,101,108,118,101,0};
				}
				case 51:
				{
					digitstr = {116,104,105,114,116,101,101,110,0};
				}
				case 52:
				{
					digitstr = {102,111,117,114,116,101,101,110,0};
				}
				case 53:
				{
					digitstr = {102,105,102,116,101,101,110,0};
				}
				case 54:
				{
					digitstr = {115,105,120,116,101,101,110,0};
				}
				case 55:
				{
					digitstr = {115,101,118,101,110,116,101,101,110,0};
				}
				case 56:
				{
					digitstr = {101,105,103,104,116,101,101,110,0};
				}
				case 57:
				{
					digitstr = {110,105,110,101,116,101,101,110,0};
				}
				default:
				{
					digitstr = {84,69,69,78,83,69,82,82,79,82,0};
				}
			}
		}
		case 50:
		{
			digitstr = {116,119,101,110,116,121,0};
		}
		case 51:
		{
			digitstr = {116,104,105,114,116,121,0};
		}
		case 52:
		{
			digitstr = {102,111,117,114,116,121,0};
		}
		case 53:
		{
			digitstr = {102,105,102,116,121,0};
		}
		case 54:
		{
			digitstr = {115,105,120,116,121,0};
		}
		case 55:
		{
			digitstr = {115,101,118,101,110,116,121,0};
		}
		case 56:
		{
			digitstr = {101,105,103,104,116,121,0};
		}
		case 57:
		{
			digitstr = {110,105,110,101,116,121,0};
		}
		default:
		{
			digitstr = {84,69,78,83,69,82,82,79,82,0};
		}
	}
	if (!dont)
	{
		format(wordnumbers, length, "%s %s", wordnumbers, digitstr);
	}
	return jumpnext;
}

getsingledigit(digit[], numbers[], length, bool:getzero)
{
	new digitstr[11];
	switch (digit[0])
	{
		case 48:
		{
			if (getzero)
			{
				digitstr = {122,101,114,111,0};
			}
			return 0;
		}
		case 49:
		{
			digitstr = {111,110,101,0};
		}
		case 50:
		{
			digitstr = {116,119,111,0};
		}
		case 51:
		{
			digitstr = {116,104,114,101,101,0};
		}
		case 52:
		{
			digitstr = {102,111,117,114,0};
		}
		case 53:
		{
			digitstr = {102,105,118,101,0};
		}
		case 54:
		{
			digitstr = {115,105,120,0};
		}
		case 55:
		{
			digitstr = {115,101,118,101,110,0};
		}
		case 56:
		{
			digitstr = {101,105,103,104,116,0};
		}
		case 57:
		{
			digitstr = {110,105,110,101,0};
		}
		default:
		{
			digitstr = {100,105,103,105,116,101,114,114,111,114,0};
		}
	}
	format(numbers, length, "%s %s", numbers, digitstr);
	return 1;
}

jghg_trim(stringtotrim[], len, charstotrim, bool:fromleft)
{
	if (0 >= charstotrim)
	{
		return 0;
	}
	if (fromleft)
	{
		new maxlen = strlen(stringtotrim);
		if (charstotrim > maxlen)
		{
			charstotrim = maxlen;
		}
		format(stringtotrim, len, "%s", stringtotrim[charstotrim]);
	}
	else
	{
		new maxlen = strlen(stringtotrim) - charstotrim;
		if (0 > maxlen)
		{
			maxlen = 0;
		}
		format(stringtotrim, maxlen, "%s", stringtotrim);
	}
	return 0;
}

BotBuild(bot, Float:closestTime, Float:longestTime)
{
	if (task_exists(bot, PLUGINNAME))
	{
		return 0;
	}
	new teamSentriesNear = GetStuffInVicinity(bot, 1500.0, true, "sentrybase") + GetStuffInVicinity(bot, 1500.0, true, "sentry");
	if (teamSentriesNear >= 1)
	{
		new name[32];
		get_user_name(bot, name, 31);
		return 0;
	}
	new Float:ltime = random_float(closestTime, longestTime);
	set_task(ltime, "sentry_build", bot, 38828, PLUGINNAME, 38012, PLUGINNAME);
	return 0;
}

public sentry_build_randomlybybot(taskid_and_id)
{
	if (!is_user_alive(taskid_and_id + -2000))
	{
		return 0;
	}
	new teamSentriesNear = GetStuffInVicinity(taskid_and_id + -2000, 1500.0, true, "sentrybase") + GetStuffInVicinity(taskid_and_id + -2000, 1500.0, true, "sentry");
	if (teamSentriesNear >= 1)
	{
		return 0;
	}
	sentry_build(taskid_and_id + -2000);
	return 0;
}

GetStuffInVicinity(entity, Float:RADIUS, bool:followTeam, STUFF[])
{
	new classname[32];
	new CsTeams:sentryTeam;
	new nrOfStuffNear;
	entity_get_string(entity, PLUGINNAME, classname, 31);
	if (followTeam)
	{
		if (equal(classname, "player", PLUGINNAME))
		{
			sentryTeam = cs_get_user_team(entity, 0);
		}
		if (equal(classname, "sentry", PLUGINNAME))
		{
			sentryTeam = GetSentryTeam(entity);
		}
	}
	if (followTeam)
	{
		if (equal(STUFF, "sentry", PLUGINNAME))
		{
			new i;
			while (i < g_sentriesNum)
			{
				new var2;
				if (entity != g_sentries[i] && (followTeam && sentryTeam != GetSentryTeam(g_sentries[i])) && entity_range(g_sentries[i], entity) > RADIUS)
				{
				}
				else
				{
					nrOfStuffNear++;
				}
				i++;
			}
		}
		if (equal(STUFF, "sentrybase", PLUGINNAME))
		{
			new ent;
			while ((ent = find_ent_by_class(ent, STUFF)))
			{
				new var3;
				if (!((followTeam && sentryTeam != entity_get_int(ent, "")) || (entity != ent && entity_get_edict(ent, 7) && entity_range(ent, entity) > RADIUS)))
				{
					nrOfStuffNear++;
				}
			}
		}
	}
	return nrOfStuffNear;
}

BotBuildRandomly(bot, Float:closestTime, Float:longestTime)
{
	new Float:ltime = random_float(closestTime, longestTime);
	set_task(ltime, "sentry_build_randomlybybot", bot + 2000, 38828, PLUGINNAME, 38012, PLUGINNAME);
	new tempname[32];
	get_user_name(bot, tempname, 31);
	return 0;
}

public playerreachedtarget(target, bot)
{
	new var1;
	if (!is_user_bot(bot) || GetSentryCount(bot) >= 2 || entity_get_int(bot, 9) || cs_get_user_vip(bot) || get_systime(PLUGINNAME) < g_lastObjectiveBuild[bot + -1][2])
	{
		return 0;
	}
	BotBuild(bot, 0.1, 5.0);
	g_lastObjectiveBuild[bot + -1] = get_systime(PLUGINNAME);
	return 0;
}

public playertouchedweaponbox(weaponbox, bot)
{
	new var1;
	if (!is_user_bot(bot) || GetSentryCount(bot) >= 2 || cs_get_user_team(bot, 0) == 2)
	{
		return 0;
	}
	new model[22];
	entity_get_string(weaponbox, 2, model, 21);
	if (!equal(model, "models/w_backpack.mdl", PLUGINNAME))
	{
		return 0;
	}
	BotBuild(bot, 0.0, 2.0);
	return 0;
}

public playerreachedhostagerescue(target, bot)
{
	new var1;
	if (!is_user_bot(bot) || GetSentryCount(bot) >= 2)
	{
		return 0;
	}
	if (cs_get_user_team(bot, 0) == 2)
	{
		if (95 > random_num(PLUGINNAME, ""))
		{
			return 0;
		}
	}
	BotBuild(bot, 0.1, 5.0);
	return 0;
}

public playertouchedhostage(hostage, bot)
{
	new var1;
	if (!is_user_bot(bot) || GetSentryCount(bot) >= 2 || cs_get_user_team(bot, 0) == 1)
	{
		return 0;
	}
	BotBuild(bot, 0.1, 5.0);
	return 0;
}

public sentryhulltouchedsentry(sentryhull, sentry)
{
	new Float:mins[3] = 0.0;
	new Float:maxs[3] = 0.0;
	mins[0] = -16.1;
	mins[1] = -16.1;
	mins[2] = 0.0;
	maxs[0] = 16.1;
	maxs[1] = 16.1;
	maxs[2] = floatadd(1111516774, 1098907648);
	entity_set_size(sentryhull, mins, maxs);
	return 0;
}

public sentrybasetouchedsentry(sentrybase, sentry)
{
	new Float:mins[3] = 0.0;
	new Float:maxs[3] = 0.0;
	mins[0] = -16.1;
	mins[1] = -16.1;
	mins[2] = 0.0;
	maxs[0] = 16.1;
	maxs[1] = 16.1;
	maxs[2] = floatadd(1111516774, 1098907648);
	entity_set_size(entity_get_edict(sentrybase, 8), mins, maxs);
	return 0;
}

public playertouchedhull(hull, player)
{
	new base = entity_get_edict(hull, 7);
	new sentry = entity_get_edict(base, 7);
	if (!sentry)
	{
		return 0;
	}
	new var1;
	if (cs_get_user_team(player, 0) == GetSentryTeam(sentry) && player != GetSentryPeople(sentry, 0))
	{
		entity_set_edict(sentry, 4, player);
		if (entity_get_edict(sentry, 7))
		{
			entity_set_edict(entity_get_edict(sentry, 7), 4, player);
		}
	}
	if (PlayerCanUpgradeSentry(player, sentry))
	{
		sentry_upgrade(player, sentry);
	}
	return 0;
}

public playertouchedsentry(sentry, player)
{
	new var1;
	if (cs_get_user_team(player, 0) == GetSentryTeam(sentry) && player != GetSentryPeople(sentry, 0))
	{
		entity_set_edict(sentry, 4, player);
		if (entity_get_edict(sentry, 7))
		{
			entity_set_edict(entity_get_edict(sentry, 7), 4, player);
		}
	}
	if (PlayerCanUpgradeSentry(player, sentry))
	{
		sentry_upgrade(player, sentry);
	}
	return 0;
}

public playertouchedsentrybase(sentrybase, player)
{
	new sentry = entity_get_edict(sentrybase, 7);
	if (!sentry)
	{
		return 0;
	}
	new var1;
	if (cs_get_user_team(player, 0) == GetSentryTeam(sentry) && player != GetSentryPeople(sentry, 0))
	{
		entity_set_edict(sentry, 4, player);
		entity_set_edict(sentrybase, 4, player);
	}
	if (PlayerCanUpgradeSentry(player, sentry))
	{
		sentry_upgrade(player, sentry);
	}
	return 0;
}

public botbuildsrandomly(parm[1])
{
	if (!is_user_connected(parm[0]))
	{
		return 0;
	}
	new Float:ltime = random_float(PLUGINNAME, 1097859072);
	new Float:ltime2 = floatadd(ltime, random_float(PLUGINNAME, 1123024896));
	BotBuildRandomly(parm[0], ltime, ltime2);
	set_task(ltime2, "botbuildsrandomly", PLUGINNAME, parm, 1, 38012, PLUGINNAME);
	return 0;
}

public holdwpn_event(id)
{
	if (!g_inBuilding[id + -1])
	{
		return 0;
	}
	entity_set_float(id, 30, 1065353216);
	return 0;
}

public client_PostThink(id)
{
	new var1;
	if (!g_inBuilding[id + -1] && g_lastInBuilding[id + -1])
	{
		set_task(1056964608, "resetspeed", id, 38828, PLUGINNAME, 38012, PLUGINNAME);
	}
	else
	{
		new var2;
		if (g_inBuilding[id + -1] && !g_lastInBuilding[id + -1])
		{
			g_maxSpeeds[id + -1] = entity_get_float(id, 30);
			entity_set_float(id, 30, 1065353216);
		}
	}
	g_lastInBuilding[id + -1] = g_inBuilding[id + -1];
	return 0;
}

public resetspeed(who)
{
	entity_set_float(who, 30, g_maxSpeeds[who + -1]);
	return 0;
}

public plugin_init()
{
	register_plugin(PLUGINNAME, VERSION, AUTHOR);
	register_clcmd("sentry_build", "createsentryhere", PLUGINNAME, "- build a sentry gun where you are", -1);
	register_clcmd("sentry_menu", "menumain", PLUGINNAME, "- displays Sentry gun menu", -1);
	register_clcmd("say", "check_say", -1, 54500, -1);
	register_clcmd("say_team", "check_say", -1, 54500, -1);
	register_event("CurWeapon", "holdwpn_event", "be", "1=1");
	register_event("ResetHUD", "newround_event", 54800, 54808);
	register_event("SendAudio", "endround_event", 54912, "2&%!MRAD_terwin", "2&%!MRAD_ctwin", "2&%!MRAD_rounddraw");
	register_event("TextMsg", "endround_event", 55212, "2&#Game_C", "2&#Game_w");
	register_event("TextMsg", "endround_event", 55392, "2&#Game_will_restart_in");
	register_forward(30, "forward_traceline_post", 1);
	if (find_ent_by_class(PLUGINNAME, "func_bomb_target"))
	{
		register_touch("func_bomb_target", "player", "playerreachedtarget");
		register_touch("weaponbox", "player", "playertouchedweaponbox");
	}
	if (find_ent_by_class(PLUGINNAME, "func_hostage_rescue"))
	{
		register_touch("func_hostage_rescue", "player", "playerreachedhostagerescue");
	}
	if (find_ent_by_class(PLUGINNAME, "func_vip_safetyzone"))
	{
		register_touch("func_vip_safetyzone", "player", "playerreachedtarget");
	}
	if (find_ent_by_class(PLUGINNAME, "hostage_entity"))
	{
		register_touch("hostage_entity", "player", "playertouchedhostage");
	}
	register_touch("sentry", "player", "playertouchedsentry");
	register_touch("sentrybase", "player", "playertouchedsentrybase");
	register_touch("sentryhull", "sentry", "sentryhulltouchedsentry");
	register_touch("sentryhull", "player", "playertouchedhull");
	register_touch("sentrybase", "sentry", "sentrybasetouchedsentry");
	g_menuId = register_menuid("\ySentry gun menu", PLUGINNAME);
	register_menucmd(g_menuId, 1023, "menumain_handle");
	register_message(23, "message_tempentity");
	register_think("sentrybase", "think_sentrybase");
	g_msgDamage = get_user_msgid("Damage");
	g_msgDeathMsg = get_user_msgid("DeathMsg");
	g_msgScoreInfo = get_user_msgid("ScoreInfo");
	g_msgHostagePos = get_user_msgid("HostagePos");
	g_msgHostageK = get_user_msgid("HostageK");
	g_MAXPLAYERS = get_global_int(16);
	g_ONEEIGHTYTHROUGHPI = floatdiv(1127481344, 1078530011);
	set_task(1084227584, "InitArmoury", PLUGINNAME, 38828, PLUGINNAME, 38012, PLUGINNAME);
	return 0;
}

