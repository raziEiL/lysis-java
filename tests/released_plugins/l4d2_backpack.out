public PlVers:__version =
{
	version = 5,
	filevers = "1.8.0.5969",
	date = "05/25/2017",
	time = "00:41:43"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
new BackpackOwner[2049];
new BackpackIndex[66];
new iModelIndex[66];
new GameMode;
new L4D2Version;
new pack_mols[66];
new pack_pipes[66];
new pack_biles[66];
new pack_kits[66];
new pack_defibs[66];
new pack_firepacks[66];
new pack_explodepacks[66];
new pack_pills[66];
new pack_adrens[66];
new pack_slot2[66];
new pack_slot3[66];
new pack_slot4[66];
new pack_store[66][9];
new item_drop[66];
new pills_owner[66];
new bool:BombUsed[66];
new bool:KitUsed[66];
new bool:PillsUsed[66];
new bool:g_InUse[66];
new bool:BackpackStart[66];
new Float:Pos[3];
new Float:Ang[3];
new Handle:pack_version;
new Handle:help_mode;
new Handle:ShowBackpack;
new Handle:IncapPickup;
new Handle:DeathDrop;
new Handle:DropNotify;
new Handle:FullNotify;
new Handle:hTrace[66];
new Handle:nadetimer[66];
new Handle:max_molotovs;
new Handle:max_pipebombs;
new Handle:max_vomitjars;
new Handle:max_kits;
new Handle:max_defibs;
new Handle:max_incendiary;
new Handle:max_explosive;
new Handle:max_pills;
new Handle:max_adrenalines;
new Handle:start_molotovs;
new Handle:start_pipebombs;
new Handle:start_vomitjars;
new Handle:start_kits;
new Handle:start_defibs;
new Handle:start_incendiary;
new Handle:start_explosive;
new Handle:start_pills;
new Handle:start_adrenalines;
public Plugin:myinfo =
{
	name = "Improved Oshroth's Backpack",
	description = "Gives players a backpack to carry extra items",
	author = "MasterMind420, Oshroth",
	version = "1.1.1",
	url = ""
};
public void:__ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("BfWrite.WriteBool");
	MarkNativeAsOptional("BfWrite.WriteByte");
	MarkNativeAsOptional("BfWrite.WriteChar");
	MarkNativeAsOptional("BfWrite.WriteShort");
	MarkNativeAsOptional("BfWrite.WriteWord");
	MarkNativeAsOptional("BfWrite.WriteNum");
	MarkNativeAsOptional("BfWrite.WriteFloat");
	MarkNativeAsOptional("BfWrite.WriteString");
	MarkNativeAsOptional("BfWrite.WriteEntity");
	MarkNativeAsOptional("BfWrite.WriteAngle");
	MarkNativeAsOptional("BfWrite.WriteCoord");
	MarkNativeAsOptional("BfWrite.WriteVecCoord");
	MarkNativeAsOptional("BfWrite.WriteVecNormal");
	MarkNativeAsOptional("BfWrite.WriteAngles");
	MarkNativeAsOptional("BfRead.ReadBool");
	MarkNativeAsOptional("BfRead.ReadByte");
	MarkNativeAsOptional("BfRead.ReadChar");
	MarkNativeAsOptional("BfRead.ReadShort");
	MarkNativeAsOptional("BfRead.ReadWord");
	MarkNativeAsOptional("BfRead.ReadNum");
	MarkNativeAsOptional("BfRead.ReadFloat");
	MarkNativeAsOptional("BfRead.ReadString");
	MarkNativeAsOptional("BfRead.ReadEntity");
	MarkNativeAsOptional("BfRead.ReadAngle");
	MarkNativeAsOptional("BfRead.ReadCoord");
	MarkNativeAsOptional("BfRead.ReadVecCoord");
	MarkNativeAsOptional("BfRead.ReadVecNormal");
	MarkNativeAsOptional("BfRead.ReadAngles");
	MarkNativeAsOptional("BfRead.GetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	MarkNativeAsOptional("Protobuf.ReadInt");
	MarkNativeAsOptional("Protobuf.ReadFloat");
	MarkNativeAsOptional("Protobuf.ReadBool");
	MarkNativeAsOptional("Protobuf.ReadString");
	MarkNativeAsOptional("Protobuf.ReadColor");
	MarkNativeAsOptional("Protobuf.ReadAngle");
	MarkNativeAsOptional("Protobuf.ReadVector");
	MarkNativeAsOptional("Protobuf.ReadVector2D");
	MarkNativeAsOptional("Protobuf.GetRepeatedFieldCount");
	MarkNativeAsOptional("Protobuf.SetInt");
	MarkNativeAsOptional("Protobuf.SetFloat");
	MarkNativeAsOptional("Protobuf.SetBool");
	MarkNativeAsOptional("Protobuf.SetString");
	MarkNativeAsOptional("Protobuf.SetColor");
	MarkNativeAsOptional("Protobuf.SetAngle");
	MarkNativeAsOptional("Protobuf.SetVector");
	MarkNativeAsOptional("Protobuf.SetVector2D");
	MarkNativeAsOptional("Protobuf.AddInt");
	MarkNativeAsOptional("Protobuf.AddFloat");
	MarkNativeAsOptional("Protobuf.AddBool");
	MarkNativeAsOptional("Protobuf.AddString");
	MarkNativeAsOptional("Protobuf.AddColor");
	MarkNativeAsOptional("Protobuf.AddAngle");
	MarkNativeAsOptional("Protobuf.AddVector");
	MarkNativeAsOptional("Protobuf.AddVector2D");
	MarkNativeAsOptional("Protobuf.RemoveRepeatedFieldValue");
	MarkNativeAsOptional("Protobuf.ReadMessage");
	MarkNativeAsOptional("Protobuf.ReadRepeatedMessage");
	MarkNativeAsOptional("Protobuf.AddMessage");
	VerifyCoreVersion();
	return void:0;
}

.2920.40000005<=0(Float:oper1, oper2)
{
	return oper1 <= float(oper2);
}

.2920.40000005<=0(Float:oper1, oper2)
{
	return oper1 <= float(oper2);
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

StrCat(String:buffer[], maxlength, String:source[])
{
	new len = strlen(buffer);
	if (len >= maxlength)
	{
		return 0;
	}
	return Format(buffer[len], maxlength - len, "%s", source);
}

GetEntSendPropOffs(ent, String:prop[], bool:actual)
{
	new String:cls[64];
	if (!GetEntityNetClass(ent, cls, 64))
	{
		return -1;
	}
	new local = -1;
	new offset = FindSendPropInfo(cls, prop, 0, 0, local);
	if (actual)
	{
		return offset;
	}
	return local;
}

bool:GetEntityClassname(entity, String:clsname[], maxlength)
{
	return !!GetEntPropString(entity, PropType:1, "m_iClassname", clsname, maxlength, 0);
}

void:SetEntityRenderMode(entity, RenderMode:mode)
{
	static bool:gotconfig;
	static String:prop[32];
	if (!gotconfig)
	{
		new Handle:gc = LoadGameConfigFile("core.games");
		new bool:exists = GameConfGetKeyValue(gc, "m_nRenderMode", prop, 32);
		CloseHandle(gc);
		if (!exists)
		{
			strcopy(prop, 32, "m_nRenderMode");
		}
		gotconfig = true;
	}
	SetEntProp(entity, PropType:0, prop, mode, 1, 0);
	return void:0;
}

void:SetEntityRenderColor(entity, r, g, b, a)
{
	static bool:gotconfig;
	static String:prop[32];
	if (!gotconfig)
	{
		new Handle:gc = LoadGameConfigFile("core.games");
		new bool:exists = GameConfGetKeyValue(gc, "m_clrRender", prop, 32);
		CloseHandle(gc);
		if (!exists)
		{
			strcopy(prop, 32, "m_clrRender");
		}
		gotconfig = true;
	}
	new offset = GetEntSendPropOffs(entity, prop, false);
	if (0 >= offset)
	{
		ThrowError("SetEntityRenderColor not supported by this mod");
	}
	SetEntData(entity, offset, r, 1, true);
	SetEntData(entity, offset + 1, g, 1, true);
	SetEntData(entity, offset + 2, b, 1, true);
	SetEntData(entity, offset + 3, a, 1, true);
	return void:0;
}

public void:OnPluginStart()
{
	GameCheck();
	RegConsoleCmd("sm_bp", PackMenu, "", 0);
	RegAdminCmd("sm_vbp", AdminViewMenu, 2, "Allows admins to view players backpacks", "", 0);
	HookEvent("item_pickup", Event_ItemPickup, EventHookMode:1);
	HookEvent("weapon_drop", Event_WeaponDrop, EventHookMode:1);
	HookEvent("player_death", Event_PlayerDeath, EventHookMode:0);
	HookEvent("round_freeze_end", Event_RoundEnd, EventHookMode:1);
	HookEvent("mission_lost", Event_MissionLost, EventHookMode:1);
	HookEvent("finale_win", Event_FinaleWin, EventHookMode:1);
	HookEvent("weapon_fire", Event_WeaponFire, EventHookMode:1);
	HookEvent("heal_success", Event_KitUsed, EventHookMode:1);
	HookEvent("defibrillator_used", Event_KitUsed, EventHookMode:1);
	HookEvent("upgrade_pack_used", Event_KitUsed, EventHookMode:1);
	HookEvent("pills_used", Event_PillsUsed, EventHookMode:1);
	HookEvent("adrenaline_used", Event_PillsUsed, EventHookMode:1);
	HookEvent("bot_player_replace", Event_BotToPlayer, EventHookMode:1);
	HookEvent("player_bot_replace", Event_PlayerToBot, EventHookMode:1);
	HookEvent("player_spawn", Player_Spawn, EventHookMode:1);
	HookEvent("player_team", TeamChange, EventHookMode:1);
	pack_version = CreateConVar("l4d_backpack_version", "1.1.1", "Backpack plugin version.", 139520, false, 0.0, false, 0.0);
	help_mode = CreateConVar("l4d_backpack_help_mode", "1", "Controls how joining help message is displayed.", 0, false, 0.0, false, 0.0);
	ShowBackpack = CreateConVar("l4d_backpack_show_backpack", "1", "[1 = Enable][0 = Disable] Show backpack model on players backs", 0, false, 0.0, false, 0.0);
	IncapPickup = CreateConVar("l4d_backpack_incap_pickup", "1", "[1 = Enable][0 = Disable] Allow picking up items while incap", 0, false, 0.0, false, 0.0);
	DeathDrop = CreateConVar("l4d_backpack_death_drop", "1", "[1 = Enable][0 = Disable] Drop backpack contents when players die", 0, false, 0.0, false, 0.0);
	DropNotify = CreateConVar("l4d_backpack_drop_notify", "1", "[1 = Enable][0 = Disable] item drop notification", 0, false, 0.0, false, 0.0);
	FullNotify = CreateConVar("l4d_backpack_full_notify", "1", "[1 = Enable][0 = Disable] item full notification", 0, false, 0.0, false, 0.0);
	max_molotovs = CreateConVar("l4d_backpack_max_mols", "1", "Max Molotovs", 0, true, 0.0, false, 0.0);
	max_pipebombs = CreateConVar("l4d_backpack_max_pipes", "1", "Max Pipe Bombs", 0, true, 0.0, false, 0.0);
	max_vomitjars = CreateConVar("l4d_backpack_max_biles", "1", "Max Bile Jars", 0, true, 0.0, false, 0.0);
	max_kits = CreateConVar("l4d_backpack_max_kits", "1", "Max Medkits", 0, true, 0.0, false, 0.0);
	max_defibs = CreateConVar("l4d_backpack_max_defibs", "1", "Max Defibs", 0, true, 0.0, false, 0.0);
	max_incendiary = CreateConVar("l4d_backpack_max_firepacks", "1", "Max Fire Ammo Packs", 0, true, 0.0, false, 0.0);
	max_explosive = CreateConVar("l4d_backpack_max_explodepacks", "1", "Max Explode Ammo Packs", 0, true, 0.0, false, 0.0);
	max_pills = CreateConVar("l4d_backpack_max_pills", "1", "Max Pills", 0, true, 0.0, false, 0.0);
	max_adrenalines = CreateConVar("l4d_backpack_max_adrens", "1", "Max Adrenalines", 0, true, 0.0, false, 0.0);
	start_molotovs = CreateConVar("l4d_backpack_start_mols", "0", "Starting Molotovs", 0, true, 0.0, false, 0.0);
	start_pipebombs = CreateConVar("l4d_backpack_start_pipes", "0", "Starting Pipe Bombs", 0, true, 0.0, false, 0.0);
	start_vomitjars = CreateConVar("l4d_backpack_start_biles", "0", "Starting Bile Jars", 0, true, 0.0, false, 0.0);
	start_kits = CreateConVar("l4d_backpack_start_kits", "0", "Starting Medkits", 0, true, 0.0, false, 0.0);
	start_defibs = CreateConVar("l4d_backpack_start_defibs", "0", "Starting Defibs", 0, true, 0.0, false, 0.0);
	start_incendiary = CreateConVar("l4d_backpack_start_firepacks", "0", "Starting Fire Ammo Packs", 0, true, 0.0, false, 0.0);
	start_explosive = CreateConVar("l4d_backpack_start_explodepacks", "0", "Starting Explode Ammo Packs", 0, true, 0.0, false, 0.0);
	start_pills = CreateConVar("l4d_backpack_start_pills", "0", "Starting Pills", 0, true, 0.0, false, 0.0);
	start_adrenalines = CreateConVar("l4d_backpack_start_adrens", "0", "Starting Adrenalines", 0, true, 0.0, false, 0.0);
	AutoExecConfig(true, "l4d_backpack", "sourcemod");
	SetConVarString(pack_version, "1.1.1", false, false);
	ResetBackpack(0, 1);
	CreateTimer(1.0, AutoItemRefill, any:0, 1);
	CreateTimer(0.4, PackLimitEnforce, any:0, 1);
	return void:0;
}

GameCheck()
{
	decl String:GameName[16];
	GetConVarString(FindConVar("mp_gamemode"), GameName, 16);
	if (StrEqual(GameName, "coop", false))
	{
		GameMode = 1;
	}
	else
	{
		if (StrEqual(GameName, "realism", false))
		{
			GameMode = 2;
		}
		if (StrEqual(GameName, "versus", false))
		{
			GameMode = 3;
		}
		if (StrEqual(GameName, "scavenge", false))
		{
			GameMode = 4;
		}
		if (StrEqual(GameName, "teamversus", false))
		{
			GameMode = 5;
		}
		if (StrEqual(GameName, "teamscavenge", false))
		{
			GameMode = 6;
		}
		if (StrEqual(GameName, "survival", false))
		{
			GameMode = 7;
		}
		GameMode = 0;
	}
	GetGameFolderName(GameName, 16);
	if (StrEqual(GameName, "left4dead2", false))
	{
		L4D2Version = 1;
	}
	else
	{
		L4D2Version = 0;
	}
	GameMode = GameMode + 0;
	return 0;
}

public void:OnClientPostAdminCheck(client)
{
	if (!IsValidClient(client))
	{
		return void:0;
	}
	if (0 < GetConVarInt(help_mode))
	{
		CreateTimer(15.0, Timer_WelcomeMessage, client, 2);
	}
	new var1;
	if (!BackpackStart[client] && !IsFakeClient(client))
	{
		StartBackpack(client);
		BackpackStart[client] = 1;
	}
	SaveBackpack(client);
	new var2;
	if (L4D2Version || !L4D2Version)
	{
		return void:0;
	}
	return void:0;
}

public Player_Spawn(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid", 0));
	if (GetConVarInt(ShowBackpack) != 1)
	{
		return 0;
	}
	CreateTimer(0.5, FixBackpackPosition, client, 2);
	return 0;
}

public Action:FixBackpackPosition(Handle:Timer, any:client)
{
	if (!IsSurvivor(client))
	{
		return Action:0;
	}
	CreateBackpack(client);
	return Action:0;
}

public void:OnGameFrame()
{
	static iFrameskip;
	iFrameskip = iFrameskip + 1 % 20;
	new var1;
	if (iFrameskip || !IsServerProcessing() || GetConVarInt(ShowBackpack) == 1)
	{
		return void:0;
	}
	new i = 1;
	while (i <= MaxClients)
	{
		new var2;
		if (!IsClientInGame(i) || !IsPlayerAlive(i))
		{
		}
		else
		{
			if (!(GetEntProp(i, PropType:1, "m_nModelIndex", 2, 0) == iModelIndex[i]))
			{
				iModelIndex[i] = GetEntProp(i, PropType:1, "m_nModelIndex", 2, 0);
				CreateBackpack(i);
			}
		}
		i++;
	}
	return void:0;
}

public Action:Timer_WelcomeMessage(Handle:timer, any:client)
{
	new var1;
	if (IsValidClient(client) && !IsFakeClient(client))
	{
		switch (GetConVarInt(help_mode))
		{
			case 1:
			{
				PrintToChat(client, "\x01[SM] Type \x04!bp\x01 in chat to access your backpack.");
			}
			case 2:
			{
				PrintHintText(client, "\x01[SM] Type \x04!bp\x01 in chat to access your backpack.");
			}
			case 3:
			{
				PrintCenterText(client, "\x01[SM] Type \x04!bp\x01 in chat to access your backpack.");
			}
			default:
			{
			}
		}
	}
	return Action:0;
}

public Action:PackLimitEnforce(Handle:timer)
{
	decl Float:cPos[3];
	new client = 1;
	while (client <= 65)
	{
		new var1;
		if (IsSurvivor(client) && IsPlayerAlive(client) && !IsFakeClient(client))
		{
			GetClientEyePosition(client, cPos);
			if (GetConVarInt(max_molotovs) < pack_mols[client])
			{
				SpawnItem(cPos, "weapon_molotov", 1);
				pack_mols[client] = GetConVarInt(max_molotovs);
			}
			if (GetConVarInt(max_pipebombs) < pack_pipes[client])
			{
				SpawnItem(cPos, "weapon_pipe_bomb", 1);
				pack_pipes[client] = GetConVarInt(max_pipebombs);
			}
			if (GetConVarInt(max_vomitjars) < pack_biles[client])
			{
				SpawnItem(cPos, "weapon_vomitjar", 1);
				pack_biles[client] = GetConVarInt(max_vomitjars);
			}
			if (GetConVarInt(max_kits) < pack_kits[client])
			{
				SpawnItem(cPos, "weapon_first_aid_kit", 1);
				pack_kits[client] = GetConVarInt(max_kits);
			}
			if (GetConVarInt(max_defibs) < pack_defibs[client])
			{
				SpawnItem(cPos, "weapon_defibrillator", 1);
				pack_defibs[client] = GetConVarInt(max_defibs);
			}
			if (GetConVarInt(max_incendiary) < pack_firepacks[client])
			{
				SpawnItem(cPos, "weapon_upgradepack_incendiary", 1);
				pack_firepacks[client] = GetConVarInt(max_incendiary);
			}
			if (GetConVarInt(max_explosive) < pack_explodepacks[client])
			{
				SpawnItem(cPos, "weapon_upgradepack_explosive", 1);
				pack_explodepacks[client] = GetConVarInt(max_explosive);
			}
			if (GetConVarInt(max_pills) < pack_pills[client])
			{
				SpawnItem(cPos, "weapon_pain_pills", 1);
				pack_pills[client] = GetConVarInt(max_pills);
			}
			if (GetConVarInt(max_adrenalines) < pack_adrens[client])
			{
				SpawnItem(cPos, "weapon_adrenaline", 1);
				pack_adrens[client] = GetConVarInt(max_adrenalines);
			}
		}
		client++;
	}
	return Action:0;
}

public Action:AutoItemRefill(Handle:timer)
{
	new client = 1;
	while (client <= 65)
	{
		new var1;
		if (IsSurvivor(client) && IsPlayerAlive(client) && !IsFakeClient(client))
		{
			new slot2 = GetPlayerWeaponSlot(client, 2);
			new slot3 = GetPlayerWeaponSlot(client, 3);
			new slot4 = GetPlayerWeaponSlot(client, 4);
			if (slot2 == -1)
			{
				if (BombUsed[client])
				{
					BombUsed[client] = 0;
					client++;
				}
				if (0 < pack_mols[client])
				{
					pack_mols[client] += -1;
					CheatCommand(client, "give", "weapon_molotov", "");
				}
				else
				{
					if (0 < pack_pipes[client])
					{
						pack_pipes[client] += -1;
						CheatCommand(client, "give", "weapon_pipe_bomb", "");
					}
					if (0 < pack_biles[client])
					{
						pack_biles[client] += -1;
						CheatCommand(client, "give", "weapon_vomitjar", "");
					}
				}
			}
			else
			{
				if (slot3 == -1)
				{
					if (KitUsed[client])
					{
						KitUsed[client] = 0;
						client++;
					}
					if (0 < pack_kits[client])
					{
						pack_kits[client] += -1;
						CheatCommand(client, "give", "weapon_first_aid_kit", "");
					}
					else
					{
						if (0 < pack_defibs[client])
						{
							pack_defibs[client] += -1;
							CheatCommand(client, "give", "weapon_defibrillator", "");
						}
						if (0 < pack_firepacks[client])
						{
							pack_firepacks[client] += -1;
							CheatCommand(client, "give", "weapon_upgradepack_incendiary", "");
						}
						if (0 < pack_explodepacks[client])
						{
							pack_explodepacks[client] += -1;
							CheatCommand(client, "give", "weapon_upgradepack_explosive", "");
						}
					}
				}
				if (slot4 == -1)
				{
					if (PillsUsed[client])
					{
						PillsUsed[client] = 0;
						client++;
					}
					if (0 < pack_pills[client])
					{
						pack_pills[client] += -1;
						CheatCommand(client, "give", "weapon_pain_pills", "");
					}
					if (0 < pack_adrens[client])
					{
						pack_adrens[client] += -1;
						CheatCommand(client, "give", "weapon_adrenaline", "");
					}
				}
			}
		}
		client++;
	}
	return Action:0;
}

public Action:Event_ItemPickup(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid", 0));
	decl String:item[32];
	GetEventString(event, "item", item, 32, "");
	item_drop[client] = 0;
	if (StrContains(item, "molotov", false) != -1)
	{
		if (nadetimer[client])
		{
			KillTimer(nadetimer[client], false);
			nadetimer[client] = 0;
			GrenadeRemove(client);
		}
		pack_slot2[client] = 1;
	}
	else
	{
		if (StrContains(item, "pipe_bomb", false) != -1)
		{
			if (nadetimer[client])
			{
				KillTimer(nadetimer[client], false);
				nadetimer[client] = 0;
				GrenadeRemove(client);
			}
			pack_slot2[client] = 2;
		}
		if (StrContains(item, "vomitjar", false) != -1)
		{
			if (nadetimer[client])
			{
				KillTimer(nadetimer[client], false);
				nadetimer[client] = 0;
				GrenadeRemove(client);
			}
			pack_slot2[client] = 3;
		}
		if (StrContains(item, "first_aid_kit", false) != -1)
		{
			pack_slot3[client] = 1;
		}
		if (StrContains(item, "defibrillator", false) != -1)
		{
			pack_slot3[client] = 2;
		}
		if (StrContains(item, "upgradepack_incendiary", false) != -1)
		{
			pack_slot3[client] = 3;
		}
		if (StrContains(item, "upgradepack_explosive", false) != -1)
		{
			pack_slot3[client] = 4;
		}
		if (StrContains(item, "pain_pills", false) != -1)
		{
			if (pills_owner[client])
			{
				CreateTimer(1.0, GivePills, pills_owner[client], 0);
				pills_owner[client] = 0;
			}
			pack_slot4[client] = 1;
			PillsUsed[client] = 0;
		}
		if (StrContains(item, "adrenaline", false) != -1)
		{
			if (pills_owner[client])
			{
				CreateTimer(1.0, GivePills, pills_owner[client], 0);
				pills_owner[client] = 0;
			}
			pack_slot4[client] = 2;
			PillsUsed[client] = 0;
		}
	}
	return Action:0;
}

public RequestFrameCallback(any:data)
{
	if (GetConVarInt(DropNotify) != 1)
	{
		return 0;
	}
	decl Float:cPos[3];
	new client = 1;
	while (client <= MaxClients)
	{
		new var1;
		if (!IsSurvivor(client) || !IsPlayerAlive(client) || IsFakeClient(client))
		{
		}
		else
		{
			GetClientEyePosition(client, cPos);
			if (GetConVarInt(max_molotovs) < pack_mols[client])
			{
				PrintToChat(client, "\x04[BP] DROPPED MOLOTOV");
			}
			if (GetConVarInt(max_pipebombs) < pack_pipes[client])
			{
				PrintToChat(client, "\x04[BP] DROPPED PIPEBOMB");
			}
			if (GetConVarInt(max_vomitjars) < pack_biles[client])
			{
				PrintToChat(client, "\x04[BP] DROPPED VOMITJAR");
			}
			if (GetConVarInt(max_kits) < pack_kits[client])
			{
				PrintToChat(client, "\x04[BP] DROPPED MEDKIT");
			}
			if (GetConVarInt(max_defibs) < pack_defibs[client])
			{
				PrintToChat(client, "\x04[BP] DROPPED DEFIB");
			}
			if (GetConVarInt(max_incendiary) < pack_firepacks[client])
			{
				PrintToChat(client, "\x04[BP] DROPPED INCENDIARY PACK");
			}
			if (GetConVarInt(max_explosive) < pack_explodepacks[client])
			{
				PrintToChat(client, "\x04[BP] DROPPED EXPLOSIVE PACK");
			}
			if (GetConVarInt(max_pills) < pack_pills[client])
			{
				PrintToChat(client, "\x04[BP] DROPPED PAIN PILLS");
			}
			if (GetConVarInt(max_adrenalines) < pack_adrens[client])
			{
				PrintToChat(client, "\x04[BP] DROPPED ADRENALINE");
			}
		}
		client++;
	}
	return 0;
}

public Action:OnPlayerRunCmd(client, &buttons, &impulse, Float:vel[3], Float:angles[3], &weapon)
{
	new var1;
	if (!client || !IsSurvivor(client) || !IsPlayerAlive(client))
	{
		return Action:0;
	}
	new var2;
	if (!g_InUse[client] && buttons & 32 == 32)
	{
		g_InUse[client] = 1;
		if (hTrace[client])
		{
			CloseHandle(hTrace[client]);
			hTrace[client] = 0;
		}
		new Float:vecAngles[3] = 0.0;
		GetClientEyeAngles(client, vecAngles);
		new Float:vecOrigin[3] = 0.0;
		GetClientEyePosition(client, vecOrigin);
		hTrace[client] = TR_TraceRayFilterEx(vecOrigin, vecAngles, -1, RayType:1, TraceRayDontHitPlayers, any:0);
		new ent = -1;
		while ((ent = FindEntityByClassname(ent, "weapon_*")) != -1)
		{
			if (IsValidEntity(ent))
			{
				new ref = EntIndexToEntRef(ent);
				new Float:endPos[3] = 0.0;
				TR_GetEndPosition(endPos, hTrace[client]);
				new Float:entPos[3] = 0.0;
				GetEntPropVector(ref, PropType:0, "m_vecOrigin", entPos, 0);
				new var3;
				if (.2920.40000005<=0(GetVectorDistance(vecOrigin, entPos, false), 100) && GetVectorDistance(entPos, endPos, false) <= 15.0)
				{
					new slotref = -1;
					new String:SlotItem[256];
					new slot2 = GetPlayerWeaponSlot(client, 2);
					new slot3 = GetPlayerWeaponSlot(client, 3);
					new slot4 = GetPlayerWeaponSlot(client, 4);
					new String:ClassName[256];
					GetEntityClassname(ref, ClassName, 256);
					new String:ModelName[256];
					GetEntPropString(ref, PropType:1, "m_ModelName", ModelName, 256, 0);
					new var4;
					if (StrContains(ModelName, "molotov", false) == -1 && StrContains(ClassName, "molotov", false) == -1)
					{
						if (GetConVarInt(max_molotovs))
						{
							if (slot2 != -1)
							{
								BombUsed[client] = 1;
								slotref = EntIndexToEntRef(slot2);
								GetEntityClassname(slotref, SlotItem, 256);
								if (StrContains(SlotItem, "molotov", false) != -1)
								{
									if (GetConVarInt(max_molotovs) == pack_mols[client])
									{
										if (GetConVarInt(FullNotify) == 1)
										{
											PrintToChat(client, "\x04[BP] MOLOTOVS ARE FULL");
										}
										return Action:0;
									}
									pack_mols[client] += 1;
									RequestFrame(RequestFrameCallback, any:0);
								}
								else
								{
									if (StrContains(SlotItem, "pipe_bomb", false) != -1)
									{
										pack_pipes[client] += 1;
										RequestFrame(RequestFrameCallback, any:0);
									}
									if (StrContains(SlotItem, "vomitjar", false) != -1)
									{
										pack_biles[client] += 1;
										RequestFrame(RequestFrameCallback, any:0);
									}
								}
								RemovePlayerItem(client, slotref);
							}
							new var5;
							if (IsPlayerIncapped(client) && GetConVarInt(IncapPickup) == 1)
							{
								AcceptEntityInput(ref, "kill", -1, -1, 0);
								CheatCommand(client, "give", "weapon_molotov", "");
							}
							return Action:0;
						}
						return Action:0;
					}
					new var6;
					if (StrContains(ModelName, "pipebomb", false) == -1 && StrContains(ClassName, "pipe_bomb", false) == -1)
					{
						if (GetConVarInt(max_pipebombs))
						{
							if (slot2 != -1)
							{
								BombUsed[client] = 1;
								slotref = EntIndexToEntRef(slot2);
								GetEntityClassname(slotref, SlotItem, 256);
								if (StrContains(SlotItem, "pipe_bomb", false) != -1)
								{
									if (GetConVarInt(max_pipebombs) == pack_pipes[client])
									{
										if (GetConVarInt(FullNotify) == 1)
										{
											PrintToChat(client, "\x04[BP] PIPEBOMBS ARE FULL");
										}
										return Action:0;
									}
									pack_pipes[client] += 1;
									RequestFrame(RequestFrameCallback, any:0);
								}
								else
								{
									if (StrContains(SlotItem, "molotov", false) != -1)
									{
										pack_mols[client] += 1;
										RequestFrame(RequestFrameCallback, any:0);
									}
									if (StrContains(SlotItem, "vomitjar", false) != -1)
									{
										pack_biles[client] += 1;
										RequestFrame(RequestFrameCallback, any:0);
									}
								}
								RemovePlayerItem(client, slotref);
							}
							new var7;
							if (IsPlayerIncapped(client) && GetConVarInt(IncapPickup) == 1)
							{
								AcceptEntityInput(ref, "kill", -1, -1, 0);
								CheatCommand(client, "give", "weapon_pipe_bomb", "");
							}
							return Action:0;
						}
						return Action:0;
					}
					new var8;
					if (StrContains(ModelName, "bile_flask", false) == -1 && StrContains(ClassName, "vomitjar", false) == -1)
					{
						if (GetConVarInt(max_vomitjars))
						{
							if (slot2 != -1)
							{
								BombUsed[client] = 1;
								slotref = EntIndexToEntRef(slot2);
								GetEntityClassname(slotref, SlotItem, 256);
								if (StrContains(SlotItem, "vomitjar", false) != -1)
								{
									if (GetConVarInt(max_vomitjars) == pack_biles[client])
									{
										if (GetConVarInt(FullNotify) == 1)
										{
											PrintToChat(client, "\x04[BP] VOMITJARS ARE FULL");
										}
										return Action:0;
									}
									pack_biles[client] += 1;
									RequestFrame(RequestFrameCallback, any:0);
								}
								else
								{
									if (StrContains(SlotItem, "molotov", false) != -1)
									{
										pack_mols[client] += 1;
										RequestFrame(RequestFrameCallback, any:0);
									}
									if (StrContains(SlotItem, "pipe_bomb", false) != -1)
									{
										pack_pipes[client] += 1;
										RequestFrame(RequestFrameCallback, any:0);
									}
								}
								RemovePlayerItem(client, slotref);
							}
							new var9;
							if (IsPlayerIncapped(client) && GetConVarInt(IncapPickup) == 1)
							{
								AcceptEntityInput(ref, "kill", -1, -1, 0);
								CheatCommand(client, "give", "weapon_vomitjar", "");
							}
							return Action:0;
						}
						return Action:0;
					}
					new var10;
					if (StrContains(ModelName, "medkit", false) == -1 && StrContains(ClassName, "first_aid_kit", false) == -1)
					{
						if (GetConVarInt(max_kits))
						{
							if (slot3 != -1)
							{
								KitUsed[client] = 1;
								slotref = EntIndexToEntRef(slot3);
								GetEntityClassname(slotref, SlotItem, 256);
								if (StrContains(SlotItem, "first_aid_kit", false) != -1)
								{
									if (GetConVarInt(max_kits) == pack_kits[client])
									{
										if (GetConVarInt(FullNotify) == 1)
										{
											PrintToChat(client, "\x04[BP] MEDKITS ARE FULL");
										}
										return Action:0;
									}
									pack_kits[client] += 1;
									RequestFrame(RequestFrameCallback, any:0);
								}
								else
								{
									if (StrContains(SlotItem, "defibrillator", false) != -1)
									{
										pack_defibs[client] += 1;
										RequestFrame(RequestFrameCallback, any:0);
									}
									if (StrContains(SlotItem, "upgradepack_incendiary", false) != -1)
									{
										pack_firepacks[client] += 1;
										RequestFrame(RequestFrameCallback, any:0);
									}
									if (StrContains(SlotItem, "upgradepack_explosive", false) != -1)
									{
										pack_explodepacks[client] += 1;
										RequestFrame(RequestFrameCallback, any:0);
									}
								}
								RemovePlayerItem(client, slotref);
							}
							new var11;
							if (IsPlayerIncapped(client) && GetConVarInt(IncapPickup) == 1)
							{
								AcceptEntityInput(ref, "kill", -1, -1, 0);
								CheatCommand(client, "give", "weapon_first_aid_kit", "");
							}
							return Action:0;
						}
						return Action:0;
					}
					new var12;
					if (StrContains(ModelName, "defibrillator", false) == -1 && StrContains(ClassName, "defibrillator", false) == -1)
					{
						if (GetConVarInt(max_defibs))
						{
							if (slot3 != -1)
							{
								KitUsed[client] = 1;
								slotref = EntIndexToEntRef(slot3);
								GetEntityClassname(slotref, SlotItem, 256);
								if (StrContains(SlotItem, "defibrillator", false) != -1)
								{
									if (GetConVarInt(max_defibs) == pack_defibs[client])
									{
										if (GetConVarInt(FullNotify) == 1)
										{
											PrintToChat(client, "\x04[BP] DEFIBS ARE FULL");
										}
										return Action:0;
									}
									pack_defibs[client] += 1;
									RequestFrame(RequestFrameCallback, any:0);
								}
								else
								{
									if (StrContains(SlotItem, "first_aid_kit", false) != -1)
									{
										pack_kits[client] += 1;
										RequestFrame(RequestFrameCallback, any:0);
									}
									if (StrContains(SlotItem, "upgradepack_incendiary", false) != -1)
									{
										pack_firepacks[client] += 1;
										RequestFrame(RequestFrameCallback, any:0);
									}
									if (StrContains(SlotItem, "upgradepack_explosive", false) != -1)
									{
										pack_explodepacks[client] += 1;
										RequestFrame(RequestFrameCallback, any:0);
									}
								}
								RemovePlayerItem(client, slotref);
							}
							new var13;
							if (IsPlayerIncapped(client) && GetConVarInt(IncapPickup) == 1)
							{
								AcceptEntityInput(ref, "kill", -1, -1, 0);
								CheatCommand(client, "give", "weapon_defibrillator", "");
							}
							return Action:0;
						}
						return Action:0;
					}
					new var14;
					if (StrContains(ModelName, "incendiary", false) == -1 && StrContains(ClassName, "upgradepack_incendiary", false) == -1)
					{
						if (GetConVarInt(max_incendiary))
						{
							if (slot3 != -1)
							{
								KitUsed[client] = 1;
								slotref = EntIndexToEntRef(slot3);
								GetEntityClassname(slotref, SlotItem, 256);
								if (StrContains(SlotItem, "upgradepack_incendiary", false) != -1)
								{
									if (GetConVarInt(max_incendiary) == pack_firepacks[client])
									{
										if (GetConVarInt(FullNotify) == 1)
										{
											PrintToChat(client, "\x04[BP] INCENDIARY PACKS ARE FULL");
										}
										return Action:0;
									}
									pack_firepacks[client] += 1;
									RequestFrame(RequestFrameCallback, any:0);
								}
								else
								{
									if (StrContains(SlotItem, "first_aid_kit", false) != -1)
									{
										pack_kits[client] += 1;
										RequestFrame(RequestFrameCallback, any:0);
									}
									if (StrContains(SlotItem, "defibrillator", false) != -1)
									{
										pack_defibs[client] += 1;
										RequestFrame(RequestFrameCallback, any:0);
									}
									if (StrContains(SlotItem, "upgradepack_explosive", false) != -1)
									{
										pack_explodepacks[client] += 1;
										RequestFrame(RequestFrameCallback, any:0);
									}
								}
								RemovePlayerItem(client, slotref);
							}
							new var15;
							if (IsPlayerIncapped(client) && GetConVarInt(IncapPickup) == 1)
							{
								AcceptEntityInput(ref, "kill", -1, -1, 0);
								CheatCommand(client, "give", "weapon_upgradepack_incendiary", "");
							}
							return Action:0;
						}
						return Action:0;
					}
					new var16;
					if (StrContains(ModelName, "explosive", false) == -1 && StrContains(ClassName, "upgradepack_explosive", false) == -1)
					{
						if (GetConVarInt(max_explosive))
						{
							if (slot3 != -1)
							{
								KitUsed[client] = 1;
								slotref = EntIndexToEntRef(slot3);
								GetEntityClassname(slotref, SlotItem, 256);
								if (StrContains(SlotItem, "upgradepack_explosive", false) != -1)
								{
									if (GetConVarInt(max_explosive) == pack_explodepacks[client])
									{
										if (GetConVarInt(FullNotify) == 1)
										{
											PrintToChat(client, "\x04[BP] EXPLOSIVE PACKS ARE FULL");
										}
										return Action:0;
									}
									pack_explodepacks[client] += 1;
									RequestFrame(RequestFrameCallback, any:0);
								}
								else
								{
									if (StrContains(SlotItem, "first_aid_kit", false) != -1)
									{
										pack_kits[client] += 1;
										RequestFrame(RequestFrameCallback, any:0);
									}
									if (StrContains(SlotItem, "defibrillator", false) != -1)
									{
										pack_defibs[client] += 1;
										RequestFrame(RequestFrameCallback, any:0);
									}
									if (StrContains(SlotItem, "upgradepack_incendiary", false) != -1)
									{
										pack_firepacks[client] += 1;
										RequestFrame(RequestFrameCallback, any:0);
									}
								}
								RemovePlayerItem(client, slotref);
							}
							new var17;
							if (IsPlayerIncapped(client) && GetConVarInt(IncapPickup) == 1)
							{
								AcceptEntityInput(ref, "kill", -1, -1, 0);
								CheatCommand(client, "give", "weapon_upgradepack_explosive", "");
							}
							return Action:0;
						}
						return Action:0;
					}
					new var18;
					if (StrContains(ModelName, "painpills", false) == -1 && StrContains(ClassName, "pain_pills", false) == -1)
					{
						if (GetConVarInt(max_pills))
						{
							if (slot4 != -1)
							{
								PillsUsed[client] = 1;
								slotref = EntIndexToEntRef(slot4);
								GetEntityClassname(slotref, SlotItem, 256);
								if (StrContains(SlotItem, "pain_pills", false) != -1)
								{
									if (GetConVarInt(max_pills) == pack_pills[client])
									{
										if (GetConVarInt(FullNotify) == 1)
										{
											PrintToChat(client, "\x04[BP] PAIN PILLS ARE FULL");
										}
										return Action:0;
									}
									pack_pills[client] += 1;
									RequestFrame(RequestFrameCallback, any:0);
								}
								else
								{
									if (StrContains(SlotItem, "adrenaline", false) != -1)
									{
										pack_adrens[client] += 1;
										RequestFrame(RequestFrameCallback, any:0);
									}
								}
								RemovePlayerItem(client, slotref);
							}
							new var19;
							if (IsPlayerIncapped(client) && GetConVarInt(IncapPickup) == 1)
							{
								AcceptEntityInput(ref, "kill", -1, -1, 0);
								CheatCommand(client, "give", "weapon_pain_pills", "");
							}
							return Action:0;
						}
						return Action:0;
					}
					new var20;
					if (StrContains(ModelName, "adrenaline", false) == -1 && StrContains(ClassName, "adrenaline", false) == -1)
					{
						if (GetConVarInt(max_adrenalines))
						{
							if (slot4 != -1)
							{
								PillsUsed[client] = 1;
								slotref = EntIndexToEntRef(slot4);
								GetEntityClassname(slotref, SlotItem, 256);
								if (StrContains(SlotItem, "adrenaline", false) != -1)
								{
									if (GetConVarInt(max_adrenalines) == pack_adrens[client])
									{
										if (GetConVarInt(FullNotify) == 1)
										{
											PrintToChat(client, "\x04[BP] ADRENALINES ARE FULL");
										}
										return Action:0;
									}
									pack_adrens[client] += 1;
									RequestFrame(RequestFrameCallback, any:0);
								}
								else
								{
									if (StrContains(SlotItem, "pain_pills", false) != -1)
									{
										pack_pills[client] += 1;
										RequestFrame(RequestFrameCallback, any:0);
									}
								}
								RemovePlayerItem(client, slotref);
							}
							new var21;
							if (IsPlayerIncapped(client) && GetConVarInt(IncapPickup) == 1)
							{
								AcceptEntityInput(ref, "kill", -1, -1, 0);
								CheatCommand(client, "give", "weapon_adrenaline", "");
							}
							return Action:0;
						}
						return Action:0;
					}
				}
			}
		}
	}
	else
	{
		new var22;
		if (g_InUse[client] && !buttons & 32)
		{
			g_InUse[client] = 0;
		}
	}
	return Action:0;
}

public Action:Event_WeaponDrop(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid", 0));
	if (!IsValidClient(client))
	{
		return Action:0;
	}
	new weapon = GetEventInt(event, "propid", 0);
	new String:item[32];
	GetEventString(event, "item", item, 32, "");
	if (StrContains(item, "molotov", false) != -1)
	{
		if (nadetimer[client])
		{
			TriggerTimer(nadetimer[client], false);
		}
		nadetimer[client] = CreateTimer(0.5, GiveGrenade, client, 0);
	}
	else
	{
		if (StrContains(item, "pipe_bomb", false) != -1)
		{
			if (nadetimer[client])
			{
				TriggerTimer(nadetimer[client], false);
			}
			nadetimer[client] = CreateTimer(0.5, GiveGrenade, client, 0);
		}
		if (StrContains(item, "vomitjar", false) != -1)
		{
			if (nadetimer[client])
			{
				TriggerTimer(nadetimer[client], false);
			}
			nadetimer[client] = CreateTimer(0.5, GiveGrenade, client, 0);
		}
		if (StrContains(item, "first_aid_kit", false) != -1)
		{
			AcceptEntityInput(weapon, "Kill", -1, -1, 0);
			pack_kits[client] += 1;
			item_drop[client] = 4;
		}
		if (StrContains(item, "defibrillator", false) != -1)
		{
			AcceptEntityInput(weapon, "Kill", -1, -1, 0);
			pack_defibs[client] += 1;
			item_drop[client] = 5;
		}
		if (StrContains(item, "upgradepack_incendiary", false) != -1)
		{
			AcceptEntityInput(weapon, "Kill", -1, -1, 0);
			pack_firepacks[client] += 1;
			item_drop[client] = 6;
		}
		if (StrContains(item, "upgradepack_explosive", false) != -1)
		{
			AcceptEntityInput(weapon, "Kill", -1, -1, 0);
			pack_explodepacks[client] += 1;
			item_drop[client] = 7;
		}
	}
	if (PillsUsed[client])
	{
		PillsUsed[client] = 0;
		return Action:0;
	}
	if (StrContains(item, "pain_pills", false) != -1)
	{
		new target = GetClientAimTarget(client, true);
		if (target > -1)
		{
			pills_owner[target] = client;
			return Action:0;
		}
		AcceptEntityInput(weapon, "Kill", -1, -1, 0);
		pack_pills[client] += 1;
		item_drop[client] = 8;
	}
	else
	{
		if (StrContains(item, "adrenaline", false) != -1)
		{
			new target = GetClientAimTarget(client, true);
			if (target > -1)
			{
				pills_owner[target] = client;
				return Action:0;
			}
			AcceptEntityInput(weapon, "Kill", -1, -1, 0);
			pack_adrens[client] += 1;
			item_drop[client] = 9;
		}
	}
	return Action:0;
}

public Action:Event_PlayerDeath(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid", 0));
	if (!IsValidClient(client))
	{
		return Action:0;
	}
	new Float:victim[3] = 0.0;
	victim[0] = GetEventFloat(event, "victim_x", 0.0);
	victim[1] = GetEventFloat(event, "victim_y", 0.0);
	victim[2] = GetEventFloat(event, "victim_z", 0.0);
	new var1;
	if (GetClientTeam(client) == 2 && GetConVarInt(DeathDrop) == 1)
	{
		SpawnItem(victim, "weapon_molotov", pack_mols[client]);
		SpawnItem(victim, "weapon_pipe_bomb", pack_pipes[client]);
		SpawnItem(victim, "weapon_vomitjar", pack_biles[client]);
		SpawnItem(victim, "weapon_first_aid_kit", pack_kits[client]);
		SpawnItem(victim, "weapon_defibrillator", pack_defibs[client]);
		SpawnItem(victim, "weapon_upgradepack_incendiary", pack_firepacks[client]);
		SpawnItem(victim, "weapon_upgradepack_explosive", pack_explodepacks[client]);
		SpawnItem(victim, "weapon_pain_pills", pack_pills[client]);
		SpawnItem(victim, "weapon_adrenaline", pack_adrens[client]);
	}
	ResetBackpack(client, 0);
	if (GetConVarInt(ShowBackpack) != 1)
	{
		return Action:0;
	}
	new iEntity = BackpackIndex[client];
	if (!IsValidEntRef(iEntity))
	{
		return Action:0;
	}
	AcceptEntityInput(iEntity, "kill", -1, -1, 0);
	BackpackIndex[client] = -1;
	return Action:0;
}

public SpawnItem(Float:origin[3], String:item[], amount)
{
	new entity = -1;
	new i = 1;
	while (i <= amount)
	{
		entity = CreateEntityByName(item, -1);
		if (!(entity == -1))
		{
			if (DispatchSpawn(entity))
			{
				DispatchKeyValue(entity, "disableshadows", "1");
				TeleportEntity(entity, origin, NULL_VECTOR, NULL_VECTOR);
				DispatchSpawn(entity);
			}
			i++;
		}
		return 0;
	}
	return 0;
}

public Action:Event_RoundEnd(Handle:event, String:name[], bool:dontBroadcast)
{
	new var1;
	if (GameMode == 1 || GameMode == 2)
	{
		new i = 1;
		while (i <= 65)
		{
			SaveBackpack(i);
			i++;
		}
	}
	return Action:0;
}

public Action:Event_FinaleWin(Handle:event, String:name[], bool:dontBroadcast)
{
	new var1;
	if (GameMode == 1 || GameMode == 2)
	{
		ResetBackpack(0, 1);
		new i = 1;
		while (i <= 65)
		{
			SaveBackpack(i);
			i++;
		}
	}
	return Action:0;
}

public Action:Event_MissionLost(Handle:event, String:name[], bool:dontBroadcast)
{
	new var1;
	if (GameMode == 1 || GameMode == 2)
	{
		new i = 1;
		while (i <= 65)
		{
			if (IsSurvivor(i))
			{
				LoadBackpack(i);
			}
			i++;
		}
	}
	return Action:0;
}

public GrenadeRemove(any:client)
{
	decl String:grenade[128];
	new Float:position[3] = 0.0;
	new Float:eyepos[3] = 0.0;
	new Float:distance = 10000.0;
	new Float:dist = 0.0;
	new entity = -1;
	new slot2 = pack_slot2[client];
	GetClientAbsOrigin(client, eyepos);
	switch (slot2)
	{
		case 1:
		{
			strcopy(grenade, 128, "weapon_molotov");
		}
		case 2:
		{
			strcopy(grenade, 128, "weapon_pipe_bomb");
		}
		case 3:
		{
			strcopy(grenade, 128, "weapon_vomitjar");
		}
		default:
		{
			return 0;
		}
	}
	new i;
	while (GetEntityCount() >= i)
	{
		if (IsValidEntity(i))
		{
			decl String:EdictName[128];
			GetEdictClassname(i, EdictName, 128);
			if (StrContains(EdictName, grenade, true) != -1)
			{
				GetEntPropVector(i, PropType:0, "m_vecOrigin", position, 0);
				dist = FloatAbs(GetVectorDistance(eyepos, position, false));
				new var1;
				if (dist < distance && 50.0 != dist)
				{
					distance = dist;
					entity = i;
				}
			}
		}
		i++;
	}
	new var2;
	if (10000.0 == distance || entity <= 0)
	{
		return 0;
	}
	AcceptEntityInput(entity, "Kill", -1, -1, 0);
	switch (slot2)
	{
		case 1:
		{
			pack_mols[client] += 1;
		}
		case 2:
		{
			pack_pipes[client] += 1;
		}
		case 3:
		{
			pack_biles[client] += 1;
		}
		default:
		{
		}
	}
	return 0;
}

public Action:Event_WeaponFire(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid", 0));
	if (!IsValidClient(client))
	{
		return Action:0;
	}
	decl String:item[12];
	GetEventString(event, "weapon", item, 10, "");
	switch (item[0])
	{
		case 109:
		{
			if (StrEqual(item, "molotov", true))
			{
				BombUsed[client] = 1;
			}
		}
		case 112:
		{
			if (StrEqual(item, "pipe_bomb", true))
			{
				BombUsed[client] = 1;
			}
		}
		case 118:
		{
			if (StrEqual(item, "vomitjar", true))
			{
				BombUsed[client] = 1;
			}
		}
		default:
		{
		}
	}
	return Action:0;
}

public Action:GiveGrenade(Handle:timer, any:client)
{
	if (!IsValidClient(client))
	{
		return Action:0;
	}
	nadetimer[client] = 0;
	new slot2 = GetPlayerWeaponSlot(client, 2);
	if (slot2 <= -1)
	{
		switch (pack_slot2[client])
		{
			case 1:
			{
				if (0 < pack_mols[client])
				{
					pack_slot2[client] = 1;
					pack_mols[client] += -1;
					CheatCommand(client, "give", "weapon_molotov", "");
				}
				else
				{
					if (0 < pack_pipes[client])
					{
						pack_slot2[client] = 2;
						pack_pipes[client] += -1;
						if (0 > pack_pipes[client])
						{
							pack_pipes[client] = 0;
						}
						CheatCommand(client, "give", "weapon_pipe_bomb", "");
					}
					if (0 < pack_biles[client])
					{
						pack_slot2[client] = 3;
						pack_biles[client] += -1;
						if (0 > pack_biles[client])
						{
							pack_biles[client] = 0;
						}
						CheatCommand(client, "give", "weapon_vomitjar", "");
					}
				}
			}
			case 2:
			{
				if (0 < pack_pipes[client])
				{
					pack_slot2[client] = 2;
					pack_pipes[client] += -1;
					CheatCommand(client, "give", "weapon_pipe_bomb", "");
				}
				else
				{
					if (0 < pack_biles[client])
					{
						pack_slot2[client] = 3;
						pack_biles[client] += -1;
						if (0 > pack_biles[client])
						{
							pack_biles[client] = 0;
						}
						CheatCommand(client, "give", "weapon_vomitjar", "");
					}
					if (0 < pack_mols[client])
					{
						pack_slot2[client] = 1;
						pack_mols[client] += -1;
						if (0 > pack_mols[client])
						{
							pack_mols[client] = 0;
						}
						CheatCommand(client, "give", "weapon_molotov", "");
					}
				}
			}
			case 3:
			{
				if (0 < pack_biles[client])
				{
					pack_slot2[client] = 3;
					pack_biles[client] += -1;
					CheatCommand(client, "give", "weapon_vomitjar", "");
				}
				else
				{
					if (0 < pack_mols[client])
					{
						pack_slot2[client] = 1;
						pack_mols[client] += -1;
						if (0 > pack_mols[client])
						{
							pack_mols[client] = 0;
						}
						CheatCommand(client, "give", "weapon_molotov", "");
					}
					if (0 < pack_pipes[client])
					{
						pack_slot2[client] = 2;
						pack_pipes[client] += -1;
						if (0 > pack_pipes[client])
						{
							pack_pipes[client] = 0;
						}
						CheatCommand(client, "give", "weapon_pipe_bomb", "");
					}
				}
			}
			default:
			{
			}
		}
	}
	return Action:0;
}

public Action:Event_KitUsed(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid", 0));
	KitUsed[client] = 1;
	new slot3 = GetPlayerWeaponSlot(client, 3);
	if (slot3 <= -1)
	{
		switch (pack_slot3[client])
		{
			case 1:
			{
				if (item_drop[client] == 4)
				{
					pack_kits[client] += -1;
				}
				if (0 < pack_kits[client])
				{
					pack_slot3[client] = 1;
					pack_kits[client] += -1;
					CheatCommand(client, "give", "weapon_first_aid_kit", "");
				}
				else
				{
					if (0 < pack_defibs[client])
					{
						pack_slot3[client] = 2;
						pack_defibs[client] += -1;
						if (0 > pack_defibs[client])
						{
							pack_defibs[client] = 0;
						}
						CheatCommand(client, "give", "weapon_defibrillator", "");
					}
					if (0 < pack_firepacks[client])
					{
						pack_slot3[client] = 3;
						pack_firepacks[client] += -1;
						if (0 > pack_firepacks[client])
						{
							pack_firepacks[client] = 0;
						}
						CheatCommand(client, "give", "weapon_upgradepack_incendiary", "");
					}
					if (0 < pack_explodepacks[client])
					{
						pack_slot3[client] = 4;
						pack_explodepacks[client] += -1;
						if (0 > pack_explodepacks[client])
						{
							pack_explodepacks[client] = 0;
						}
						CheatCommand(client, "give", "weapon_upgradepack_explosive", "");
					}
				}
			}
			case 2:
			{
				if (item_drop[client] == 5)
				{
					pack_defibs[client] += -1;
				}
				if (0 < pack_defibs[client])
				{
					pack_slot3[client] = 2;
					pack_defibs[client] += -1;
					CheatCommand(client, "give", "weapon_defibrillator", "");
				}
				else
				{
					if (0 < pack_firepacks[client])
					{
						pack_slot3[client] = 3;
						pack_firepacks[client] += -1;
						if (0 > pack_firepacks[client])
						{
							pack_firepacks[client] = 0;
						}
						CheatCommand(client, "give", "weapon_upgradepack_incendiary", "");
					}
					if (0 < pack_explodepacks[client])
					{
						pack_slot3[client] = 4;
						pack_explodepacks[client] += -1;
						if (0 > pack_explodepacks[client])
						{
							pack_explodepacks[client] = 0;
						}
						CheatCommand(client, "give", "weapon_upgradepack_explosive", "");
					}
					if (0 < pack_kits[client])
					{
						pack_slot3[client] = 1;
						pack_kits[client] += -1;
						if (0 > pack_kits[client])
						{
							pack_kits[client] = 0;
						}
						CheatCommand(client, "give", "weapon_first_aid_kit", "");
					}
				}
			}
			case 3:
			{
				if (item_drop[client] == 6)
				{
					pack_firepacks[client] += -1;
				}
				if (0 < pack_firepacks[client])
				{
					pack_slot3[client] = 3;
					pack_firepacks[client] += -1;
					CheatCommand(client, "give", "weapon_upgradepack_incendiary", "");
				}
				else
				{
					if (0 < pack_explodepacks[client])
					{
						pack_slot3[client] = 4;
						pack_explodepacks[client] += -1;
						if (0 > pack_explodepacks[client])
						{
							pack_explodepacks[client] = 0;
						}
						CheatCommand(client, "give", "weapon_upgradepack_explosive", "");
					}
					if (0 < pack_kits[client])
					{
						pack_slot3[client] = 1;
						pack_kits[client] += -1;
						if (0 > pack_kits[client])
						{
							pack_kits[client] = 0;
						}
						CheatCommand(client, "give", "weapon_first_aid_kit", "");
					}
					if (0 < pack_defibs[client])
					{
						pack_slot3[client] = 2;
						pack_defibs[client] += -1;
						if (0 > pack_defibs[client])
						{
							pack_defibs[client] = 0;
						}
						CheatCommand(client, "give", "weapon_defibrillator", "");
					}
				}
			}
			case 4:
			{
				if (item_drop[client] == 7)
				{
					pack_explodepacks[client] += -1;
				}
				if (0 < pack_explodepacks[client])
				{
					pack_slot3[client] = 4;
					pack_explodepacks[client] += -1;
					CheatCommand(client, "give", "weapon_upgradepack_explosive", "");
				}
				else
				{
					if (0 < pack_kits[client])
					{
						pack_slot3[client] = 1;
						pack_kits[client] += -1;
						if (0 > pack_kits[client])
						{
							pack_kits[client] = 0;
						}
						CheatCommand(client, "give", "weapon_first_aid_kit", "");
					}
					if (0 < pack_defibs[client])
					{
						pack_slot3[client] = 2;
						pack_defibs[client] += -1;
						if (0 > pack_defibs[client])
						{
							pack_defibs[client] = 0;
						}
						CheatCommand(client, "give", "weapon_defibrillator", "");
					}
					if (0 < pack_firepacks[client])
					{
						pack_slot3[client] = 3;
						pack_firepacks[client] += -1;
						if (0 > pack_firepacks[client])
						{
							pack_firepacks[client] = 0;
						}
						CheatCommand(client, "give", "weapon_upgradepack_incendiary", "");
					}
				}
			}
			default:
			{
			}
		}
		item_drop[client] = 0;
	}
	return Action:0;
}

public Action:Event_PillsUsed(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid", 0));
	PillsUsed[client] = 1;
	CreateTimer(1.0, GivePills, client, 0);
	return Action:0;
}

public Action:GivePills(Handle:timer, any:client)
{
	if (!IsValidClient(client))
	{
		return Action:0;
	}
	new slot4 = GetPlayerWeaponSlot(client, 4);
	if (slot4 <= -1)
	{
		switch (pack_slot4[client])
		{
			case 1:
			{
				if (item_drop[client] == 8)
				{
					pack_pills[client] += -1;
				}
				if (0 < pack_pills[client])
				{
					pack_slot4[client] = 1;
					pack_pills[client] += -1;
					CheatCommand(client, "give", "weapon_pain_pills", "");
				}
				else
				{
					if (0 < pack_adrens[client])
					{
						pack_slot4[client] = 2;
						pack_adrens[client] += -1;
						if (0 > pack_adrens[client])
						{
							pack_adrens[client] = 0;
						}
						CheatCommand(client, "give", "weapon_adrenaline", "");
					}
				}
			}
			case 2:
			{
				if (item_drop[client] == 9)
				{
					pack_adrens[client] += -1;
				}
				if (0 < pack_adrens[client])
				{
					pack_slot4[client] = 2;
					pack_adrens[client] += -1;
					CheatCommand(client, "give", "weapon_adrenaline", "");
				}
				else
				{
					if (0 < pack_pills[client])
					{
						pack_slot4[client] = 1;
						pack_pills[client] += -1;
						if (0 > pack_pills[client])
						{
							pack_pills[client] = 0;
						}
						CheatCommand(client, "give", "weapon_pain_pills", "");
					}
				}
			}
			default:
			{
			}
		}
		item_drop[client] = 0;
	}
	return Action:0;
}

public Action:Event_PlayerToBot(Handle:event, String:name[], bool:dontBroadcast)
{
	new bot = GetClientOfUserId(GetEventInt(event, "bot", 0));
	new player = GetClientOfUserId(GetEventInt(event, "player", 0));
	new var2 = pack_mols[bot];
	var2 = pack_mols[player][var2];
	new var3 = pack_pipes[bot];
	var3 = pack_pipes[player][var3];
	new var4 = pack_biles[bot];
	var4 = pack_biles[player][var4];
	new var5 = pack_kits[bot];
	var5 = pack_kits[player][var5];
	new var6 = pack_defibs[bot];
	var6 = pack_defibs[player][var6];
	new var7 = pack_firepacks[bot];
	var7 = pack_firepacks[player][var7];
	new var8 = pack_explodepacks[bot];
	var8 = pack_explodepacks[player][var8];
	new var9 = pack_pills[bot];
	var9 = pack_pills[player][var9];
	new var10 = pack_adrens[bot];
	var10 = pack_adrens[player][var10];
	pack_slot2[bot] = pack_slot2[player];
	pack_slot3[bot] = 1;
	pack_slot4[bot] = pack_slot4[player];
	item_drop[bot] = 0;
	pills_owner[bot] = pills_owner[player];
	BombUsed[bot] = 0;
	KitUsed[bot] = 0;
	PillsUsed[bot] = 0;
	ResetBackpack(player, 0);
	new var1;
	if (GameMode == 1 || GameMode == 2)
	{
		new var11 = pack_store[bot];
		var11[0] = pack_store[player][0] + var11[0];
		new var12 = pack_store[bot][1];
		var12 = pack_store[player][1][var12];
		new var13 = pack_store[bot][2];
		var13 = pack_store[player][2][var13];
		new var14 = pack_store[bot][3];
		var14 = pack_store[player][3][var14];
		new var15 = pack_store[bot][4];
		var15 = pack_store[player][4][var15];
		new var16 = pack_store[bot][5];
		var16 = pack_store[player][5][var16];
		new var17 = pack_store[bot][6];
		var17 = pack_store[player][6][var17];
		new var18 = pack_store[bot][7];
		var18 = pack_store[player][7][var18];
		new var19 = pack_store[bot][8];
		var19 = pack_store[player][8][var19];
		pack_store[player][0] = 0;
		pack_store[player][1] = 0;
		pack_store[player][2] = 0;
		pack_store[player][3] = 0;
		pack_store[player][4] = 0;
		pack_store[player][5] = 0;
		pack_store[player][6] = 0;
		pack_store[player][7] = 0;
		pack_store[player][8] = 0;
	}
	return Action:0;
}

public Action:Event_BotToPlayer(Handle:event, String:name[], bool:dontBroadcast)
{
	new bot = GetClientOfUserId(GetEventInt(event, "bot", 0));
	new player = GetClientOfUserId(GetEventInt(event, "player", 0));
	new var2 = pack_mols[player];
	var2 = pack_mols[bot][var2];
	new var3 = pack_pipes[player];
	var3 = pack_pipes[bot][var3];
	new var4 = pack_biles[player];
	var4 = pack_biles[bot][var4];
	new var5 = pack_kits[player];
	var5 = pack_kits[bot][var5];
	new var6 = pack_defibs[player];
	var6 = pack_defibs[bot][var6];
	new var7 = pack_firepacks[player];
	var7 = pack_firepacks[bot][var7];
	new var8 = pack_explodepacks[player];
	var8 = pack_explodepacks[bot][var8];
	new var9 = pack_pills[player];
	var9 = pack_pills[bot][var9];
	new var10 = pack_adrens[player];
	var10 = pack_adrens[bot][var10];
	pack_slot2[player] = pack_slot2[bot];
	pack_slot3[player] = pack_slot3[bot];
	pack_slot4[player] = pack_slot4[bot];
	item_drop[player] = 0;
	pills_owner[player] = 0;
	BombUsed[player] = 0;
	KitUsed[player] = 0;
	PillsUsed[player] = 0;
	ResetBackpack(bot, 0);
	new var1;
	if (GameMode == 1 || GameMode == 2)
	{
		new var11 = pack_store[player];
		var11[0] = pack_store[bot][0] + var11[0];
		new var12 = pack_store[player][1];
		var12 = pack_store[bot][1][var12];
		new var13 = pack_store[player][2];
		var13 = pack_store[bot][2][var13];
		new var14 = pack_store[player][3];
		var14 = pack_store[bot][3][var14];
		new var15 = pack_store[player][4];
		var15 = pack_store[bot][4][var15];
		new var16 = pack_store[player][5];
		var16 = pack_store[bot][5][var16];
		new var17 = pack_store[player][6];
		var17 = pack_store[bot][6][var17];
		new var18 = pack_store[player][7];
		var18 = pack_store[bot][7][var18];
		new var19 = pack_store[player][8];
		var19 = pack_store[bot][8][var19];
		pack_store[bot][0] = 0;
		pack_store[bot][1] = 0;
		pack_store[bot][2] = 0;
		pack_store[bot][3] = 0;
		pack_store[bot][4] = 0;
		pack_store[bot][5] = 0;
		pack_store[bot][6] = 0;
		pack_store[bot][7] = 0;
		pack_store[bot][8] = 0;
	}
	return Action:0;
}

ResetBackpack(client, reset)
{
	new mols;
	new pipes;
	new biles;
	new kits;
	new defibs;
	new firepacks;
	new explodepacks;
	new pills;
	new adrens;
	if (reset == 1)
	{
		mols = GetConVarInt(FindConVar("l4d_backpack_start_mols"));
		pipes = GetConVarInt(FindConVar("l4d_backpack_start_pipes"));
		biles = GetConVarInt(FindConVar("l4d_backpack_start_biles"));
		kits = GetConVarInt(FindConVar("l4d_backpack_start_kits"));
		defibs = GetConVarInt(FindConVar("l4d_backpack_start_defibs"));
		firepacks = GetConVarInt(FindConVar("l4d_backpack_start_firepacks"));
		explodepacks = GetConVarInt(FindConVar("l4d_backpack_start_explodepacks"));
		pills = GetConVarInt(FindConVar("l4d_backpack_start_pills"));
		adrens = GetConVarInt(FindConVar("l4d_backpack_start_adrens"));
	}
	if (client)
	{
		pack_mols[client] = mols;
		pack_pipes[client] = pipes;
		pack_biles[client] = biles;
		pack_kits[client] = kits;
		pack_defibs[client] = defibs;
		pack_firepacks[client] = firepacks;
		pack_explodepacks[client] = explodepacks;
		pack_pills[client] = pills;
		pack_adrens[client] = adrens;
		pack_slot2[client] = 0;
		pack_slot3[client] = 0;
		pack_slot4[client] = 0;
		item_drop[client] = 0;
		pills_owner[client] = 0;
		BombUsed[client] = 0;
		KitUsed[client] = 0;
		PillsUsed[client] = 0;
		nadetimer[client] = 0;
		return 0;
	}
	new i;
	while (i <= 65)
	{
		pack_mols[i] = mols;
		pack_pipes[i] = pipes;
		pack_biles[i] = biles;
		pack_kits[i] = kits;
		pack_defibs[i] = defibs;
		pack_firepacks[i] = firepacks;
		pack_explodepacks[i] = explodepacks;
		pack_pills[i] = pills;
		pack_adrens[i] = adrens;
		pack_slot2[i] = 0;
		pack_slot3[i] = 0;
		pack_slot4[i] = 0;
		item_drop[i] = 0;
		pills_owner[i] = 0;
		BombUsed[i] = 0;
		KitUsed[i] = 0;
		PillsUsed[i] = 0;
		nadetimer[i] = 0;
		i++;
	}
	return 0;
}

StartBackpack(client)
{
	pack_mols[client] = GetConVarInt(start_molotovs);
	pack_pipes[client] = GetConVarInt(start_pipebombs);
	pack_biles[client] = GetConVarInt(start_vomitjars);
	pack_kits[client] = GetConVarInt(start_kits);
	pack_defibs[client] = GetConVarInt(start_defibs);
	pack_firepacks[client] = GetConVarInt(start_incendiary);
	pack_explodepacks[client] = GetConVarInt(start_explosive);
	pack_pills[client] = GetConVarInt(start_pills);
	pack_adrens[client] = GetConVarInt(start_adrenalines);
	return 0;
}

SaveBackpack(client)
{
	pack_store[client][0] = pack_mols[client];
	pack_store[client][1] = pack_pipes[client];
	pack_store[client][2] = pack_biles[client];
	pack_store[client][3] = pack_kits[client];
	pack_store[client][4] = pack_defibs[client];
	pack_store[client][5] = pack_firepacks[client];
	pack_store[client][6] = pack_explodepacks[client];
	pack_store[client][7] = pack_pills[client];
	pack_store[client][8] = pack_adrens[client];
	return 0;
}

LoadBackpack(client)
{
	pack_mols[client] = pack_store[client][0];
	pack_pipes[client] = pack_store[client][1];
	pack_biles[client] = pack_store[client][2];
	pack_kits[client] = pack_store[client][3];
	pack_defibs[client] = pack_store[client][4];
	pack_firepacks[client] = pack_store[client][5];
	pack_explodepacks[client] = pack_store[client][6];
	pack_pills[client] = pack_store[client][7];
	pack_adrens[client] = pack_store[client][8];
	return 0;
}

public Action:PackMenu(client, arg)
{
	new iSlot;
	new entity;
	decl String:sSlot[128];
	decl String:EdictName[128];
	new var1;
	if (IsClientInGame(client) && !IsFakeClient(client))
	{
		if (GetClientTeam(client) == 2)
		{
			if (IsPlayerAlive(client))
			{
				GetCmdArg(1, sSlot, 128);
				iSlot = StringToInt(sSlot, 10);
				switch (iSlot)
				{
					case 1, 2, 3:
					{
						entity = GetPlayerWeaponSlot(client, 2);
						if (entity > -1)
						{
							GetEdictClassname(entity, EdictName, 128);
							if (StrContains(EdictName, "molotov", false) != -1)
							{
								RemovePlayerItem(client, entity);
								pack_mols[client] += 1;
							}
							if (StrContains(EdictName, "pipe_bomb", false) != -1)
							{
								RemovePlayerItem(client, entity);
								pack_pipes[client] += 1;
							}
							if (StrContains(EdictName, "vomitjar", false) != -1)
							{
								RemovePlayerItem(client, entity);
								pack_biles[client] += 1;
							}
						}
						pack_slot2[client] = iSlot;
						switch (iSlot)
						{
							case 1:
							{
								if (0 < pack_mols[client])
								{
									CheatCommand(client, "give", "weapon_molotov", "");
									pack_mols[client] += -1;
								}
								else
								{
									pack_slot2[client] = 0;
								}
							}
							case 2:
							{
								if (0 < pack_pipes[client])
								{
									CheatCommand(client, "give", "weapon_pipe_bomb", "");
									pack_pipes[client] += -1;
								}
								else
								{
									pack_slot2[client] = 0;
								}
							}
							case 3:
							{
								if (0 < pack_biles[client])
								{
									CheatCommand(client, "give", "weapon_vomitjar", "");
									pack_biles[client] += -1;
								}
								else
								{
									pack_slot2[client] = 0;
								}
							}
							default:
							{
							}
						}
					}
					case 4, 5, 6, 7:
					{
						entity = GetPlayerWeaponSlot(client, 3);
						if (entity > -1)
						{
							GetEdictClassname(entity, EdictName, 128);
							if (StrContains(EdictName, "first_aid_kit", false) != -1)
							{
								RemovePlayerItem(client, entity);
								pack_kits[client] += 1;
							}
							if (StrContains(EdictName, "defibrillator", false) != -1)
							{
								RemovePlayerItem(client, entity);
								pack_defibs[client] += 1;
							}
							if (StrContains(EdictName, "upgradepack_incendiary", false) != -1)
							{
								RemovePlayerItem(client, entity);
								pack_firepacks[client] += 1;
							}
							if (StrContains(EdictName, "upgradepack_explosive", false) != -1)
							{
								RemovePlayerItem(client, entity);
								pack_explodepacks[client] += 1;
							}
						}
						pack_slot2[client] = iSlot + -3;
						switch (iSlot + -3)
						{
							case 1:
							{
								if (0 < pack_kits[client])
								{
									CheatCommand(client, "give", "weapon_first_aid_kit", "");
									pack_kits[client] += -1;
								}
								else
								{
									pack_slot3[client] = 0;
								}
							}
							case 2:
							{
								if (0 < pack_defibs[client])
								{
									CheatCommand(client, "give", "weapon_defibrillator", "");
									pack_defibs[client] += -1;
								}
								else
								{
									pack_slot3[client] = 0;
								}
							}
							case 3:
							{
								if (0 < pack_firepacks[client])
								{
									CheatCommand(client, "give", "weapon_upgradepack_incendiary", "");
									pack_firepacks[client] += -1;
								}
								else
								{
									pack_slot3[client] = 0;
								}
							}
							case 4:
							{
								if (0 < pack_explodepacks[client])
								{
									CheatCommand(client, "give", "weapon_upgradepack_explosive", "");
									pack_explodepacks[client] += -1;
								}
								else
								{
									pack_slot3[client] = 0;
								}
							}
							default:
							{
							}
						}
					}
					case 8, 9:
					{
						entity = GetPlayerWeaponSlot(client, 4);
						if (entity > -1)
						{
							GetEdictClassname(entity, EdictName, 128);
							if (StrContains(EdictName, "pain_pills", false) != -1)
							{
								RemovePlayerItem(client, entity);
								pack_pills[client] += 1;
							}
							if (StrContains(EdictName, "adrenaline", false) != -1)
							{
								RemovePlayerItem(client, entity);
								pack_adrens[client] += 1;
							}
						}
						pack_slot4[client] = iSlot + -7;
						switch (iSlot + -7)
						{
							case 1:
							{
								if (0 < pack_pills[client])
								{
									CheatCommand(client, "give", "weapon_pain_pills", "");
									pack_pills[client] += -1;
								}
								else
								{
									pack_slot4[client] = 0;
								}
							}
							case 2:
							{
								if (0 < pack_adrens[client])
								{
									CheatCommand(client, "give", "weapon_adrenaline", "");
									pack_adrens[client] += -1;
								}
								else
								{
									pack_slot4[client] = 0;
								}
							}
							default:
							{
							}
						}
					}
					default:
					{
						showpackHUD(client);
					}
				}
			}
			else
			{
				PrintToChat(client, "You cannot access your Backpack while dead.");
			}
		}
		PrintToChat(client, "Only survivors can access the backpack.");
	}
	return Action:3;
}

public showpackHUD(client)
{
	decl String:line[100];
	new Handle:panel = CreatePanel(Handle:0);
	SetPanelTitle(panel, "-----> BACKPACK <-----", false);
	Format(line, 100, "Molotovs: %d", pack_mols[client]);
	if (pack_slot2[client] == 1)
	{
		StrCat(line, 100, " <--");
	}
	DrawPanelItem(panel, line, 0);
	Format(line, 100, "Pipe Bombs: %d", pack_pipes[client]);
	if (pack_slot2[client] == 2)
	{
		StrCat(line, 100, " <--");
	}
	DrawPanelItem(panel, line, 0);
	Format(line, 100, "Bile Bombs: %d", pack_biles[client]);
	if (pack_slot2[client] == 3)
	{
		StrCat(line, 100, " <--");
	}
	DrawPanelItem(panel, line, 0);
	Format(line, 100, "Medkits: %d", pack_kits[client]);
	if (pack_slot3[client] == 1)
	{
		StrCat(line, 100, " <--");
	}
	DrawPanelItem(panel, line, 0);
	Format(line, 100, "Defibs: %d", pack_defibs[client]);
	if (pack_slot3[client] == 2)
	{
		StrCat(line, 100, " <--");
	}
	DrawPanelItem(panel, line, 0);
	Format(line, 100, "Incendiary Packs: %d", pack_firepacks[client]);
	if (pack_slot3[client] == 3)
	{
		StrCat(line, 100, " <--");
	}
	DrawPanelItem(panel, line, 0);
	Format(line, 100, "Explosive Packs: %d", pack_explodepacks[client]);
	if (pack_slot3[client] == 4)
	{
		StrCat(line, 100, " <--");
	}
	DrawPanelItem(panel, line, 0);
	Format(line, 100, "Pills: %d", pack_pills[client]);
	if (pack_slot4[client] == 1)
	{
		StrCat(line, 100, " <--");
	}
	DrawPanelItem(panel, line, 0);
	Format(line, 100, "Adrenaline: %d", pack_adrens[client]);
	if (pack_slot4[client] == 2)
	{
		StrCat(line, 100, " <--");
	}
	DrawPanelItem(panel, line, 0);
	DrawPanelItem(panel, "Exit", 0);
	SendPanelToClient(panel, client, Panel_Backpack, 60);
	CloseHandle(panel);
	return 0;
}

public Panel_Backpack(Handle:menu, MenuAction:action, param1, param2)
{
	if (!action == 4)
	{
		return 0;
	}
	new entity;
	decl String:EdictName[128];
	switch (param2)
	{
		case 1, 2, 3:
		{
			entity = GetPlayerWeaponSlot(param1, 2);
			if (entity > -1)
			{
				GetEdictClassname(entity, EdictName, 128);
				if (StrContains(EdictName, "molotov", false) != -1)
				{
					RemovePlayerItem(param1, entity);
					pack_mols[param1] += 1;
				}
				if (StrContains(EdictName, "pipe_bomb", false) != -1)
				{
					RemovePlayerItem(param1, entity);
					pack_pipes[param1] += 1;
				}
				if (StrContains(EdictName, "vomitjar", false) != -1)
				{
					RemovePlayerItem(param1, entity);
					pack_biles[param1] += 1;
				}
			}
			pack_slot2[param1] = param2;
			switch (param2)
			{
				case 1:
				{
					if (0 < pack_mols[param1])
					{
						CheatCommand(param1, "give", "weapon_molotov", "");
						pack_mols[param1] += -1;
					}
					else
					{
						pack_slot2[param1] = 0;
					}
				}
				case 2:
				{
					if (0 < pack_pipes[param1])
					{
						CheatCommand(param1, "give", "weapon_pipe_bomb", "");
						pack_pipes[param1] += -1;
					}
					else
					{
						pack_slot2[param1] = 0;
					}
				}
				case 3:
				{
					if (0 < pack_biles[param1])
					{
						CheatCommand(param1, "give", "weapon_vomitjar", "");
						pack_biles[param1] += -1;
					}
					else
					{
						pack_slot2[param1] = 0;
					}
				}
				default:
				{
				}
			}
		}
		case 4, 5, 6, 7:
		{
			entity = GetPlayerWeaponSlot(param1, 3);
			if (entity > -1)
			{
				GetEdictClassname(entity, EdictName, 128);
				if (StrContains(EdictName, "first_aid_kit", false) != -1)
				{
					RemovePlayerItem(param1, entity);
					pack_kits[param1] += 1;
				}
				if (StrContains(EdictName, "defibrillator", false) != -1)
				{
					RemovePlayerItem(param1, entity);
					pack_defibs[param1] += 1;
				}
				if (StrContains(EdictName, "upgradepack_incendiary", false) != -1)
				{
					RemovePlayerItem(param1, entity);
					pack_firepacks[param1] += 1;
				}
				if (StrContains(EdictName, "upgradepack_explosive", false) != -1)
				{
					RemovePlayerItem(param1, entity);
					pack_explodepacks[param1] += 1;
				}
			}
			pack_slot2[param1] = param2 + -3;
			switch (param2 + -3)
			{
				case 1:
				{
					if (0 < pack_kits[param1])
					{
						CheatCommand(param1, "give", "weapon_first_aid_kit", "");
						pack_kits[param1] += -1;
					}
					else
					{
						pack_slot3[param1] = 0;
					}
				}
				case 2:
				{
					if (0 < pack_defibs[param1])
					{
						CheatCommand(param1, "give", "weapon_defibrillator", "");
						pack_defibs[param1] += -1;
					}
					else
					{
						pack_slot3[param1] = 0;
					}
				}
				case 3:
				{
					if (0 < pack_firepacks[param1])
					{
						CheatCommand(param1, "give", "weapon_upgradepack_incendiary", "");
						pack_firepacks[param1] += -1;
					}
					else
					{
						pack_slot3[param1] = 0;
					}
				}
				case 4:
				{
					if (0 < pack_explodepacks[param1])
					{
						CheatCommand(param1, "give", "weapon_upgradepack_explosive", "");
						pack_explodepacks[param1] += -1;
					}
					else
					{
						pack_slot3[param1] = 0;
					}
				}
				default:
				{
				}
			}
		}
		case 8, 9:
		{
			entity = GetPlayerWeaponSlot(param1, 4);
			if (entity > -1)
			{
				GetEdictClassname(entity, EdictName, 128);
				if (StrContains(EdictName, "pain_pills", false) != -1)
				{
					RemovePlayerItem(param1, entity);
					pack_pills[param1] += 1;
				}
				if (StrContains(EdictName, "adrenaline", false) != -1)
				{
					RemovePlayerItem(param1, entity);
					pack_adrens[param1] += 1;
				}
			}
			pack_slot4[param1] = param2 + -7;
			switch (param2 + -7)
			{
				case 1:
				{
					if (0 < pack_pills[param1])
					{
						CheatCommand(param1, "give", "weapon_pain_pills", "");
						pack_pills[param1] += -1;
					}
					else
					{
						pack_slot4[param1] = 0;
					}
				}
				case 2:
				{
					if (0 < pack_adrens[param1])
					{
						CheatCommand(param1, "give", "weapon_adrenaline", "");
						pack_adrens[param1] += -1;
					}
					else
					{
						pack_slot4[param1] = 0;
					}
				}
				default:
				{
				}
			}
		}
		default:
		{
		}
	}
	return 0;
}

public Action:AdminViewMenu(client, args)
{
	decl String:line[100];
	new Handle:panel = CreatePanel(Handle:0);
	SetPanelTitle(panel, "-----> ADMIN BACKPACK VIEW <-----", false);
	Format(line, 100, "Players: %3d %3d %3d %3d %3d %3d %3d %3d", 1, 2, 3, 4, 5, 6, 7, 8);
	DrawPanelText(panel, line);
	Format(line, 100, "Molotovs: %3d %3d %3d %3d %3d %3d %3d %3d", 11260 + 4, 11260 + 8, 11260 + 12, 11260 + 16, 11260 + 20, 11260 + 24, 11260 + 28, 11260 + 32);
	DrawPanelItem(panel, line, 0);
	Format(line, 100, "Pipe Bombs: %3d %3d %3d %3d %3d %3d %3d %3d", 11524 + 4, 11524 + 8, 11524 + 12, 11524 + 16, 11524 + 20, 11524 + 24, 11524 + 28, 11524 + 32);
	DrawPanelItem(panel, line, 0);
	Format(line, 100, "Bile Bombs: %3d %3d %3d %3d %3d %3d %3d %3d", 11788 + 4, 11788 + 8, 11788 + 12, 11788 + 16, 11788 + 20, 11788 + 24, 11788 + 28, 11788 + 32);
	DrawPanelItem(panel, line, 0);
	Format(line, 100, "Medkits: %3d %3d %3d %3d %3d %3d %3d %3d", 12052 + 4, 12052 + 8, 12052 + 12, 12052 + 16, 12052 + 20, 12052 + 24, 12052 + 28, 12052 + 32);
	DrawPanelItem(panel, line, 0);
	Format(line, 100, "Defibs: %3d %3d %3d %3d %3d %3d %3d %3d", 12316 + 4, 12316 + 8, 12316 + 12, 12316 + 16, 12316 + 20, 12316 + 24, 12316 + 28, 12316 + 32);
	DrawPanelItem(panel, line, 0);
	Format(line, 100, "Incediary Packs: %3d %3d %3d %3d %3d %3d %3d %3d", 12580 + 4, 12580 + 8, 12580 + 12, 12580 + 16, 12580 + 20, 12580 + 24, 12580 + 28, 12580 + 32);
	DrawPanelItem(panel, line, 0);
	Format(line, 100, "Explosive Packs: %3d %3d %3d %3d %3d %3d %3d %3d", 12844 + 4, 12844 + 8, 12844 + 12, 12844 + 16, 12844 + 20, 12844 + 24, 12844 + 28, 12844 + 32);
	DrawPanelItem(panel, line, 0);
	Format(line, 100, "Pills: %3d %3d %3d %3d %3d %3d %3d %3d", 13108 + 4, 13108 + 8, 13108 + 12, 13108 + 16, 13108 + 20, 13108 + 24, 13108 + 28, 13108 + 32);
	DrawPanelItem(panel, line, 0);
	Format(line, 100, "Adrenaline: %3d %3d %3d %3d %3d %3d %3d %3d", 13372 + 4, 13372 + 8, 13372 + 12, 13372 + 16, 13372 + 20, 13372 + 24, 13372 + 28, 13372 + 32);
	DrawPanelItem(panel, line, 0);
	DrawPanelItem(panel, "Exit", 0);
	SendPanelToClient(panel, client, Panel_Nothing, 60);
	CloseHandle(panel);
	return Action:3;
}

public Panel_Nothing(Handle:menu, MenuAction:action, param1, param2)
{
	return 0;
}

public TeamChange(Handle:hEvent, String:sEventName[], bool:bDontBroadcast)
{
	new iClient = GetClientOfUserId(GetEventInt(hEvent, "userid", 0));
	new var1;
	if (iClient < 1 || iClient > MaxClients || !IsClientInGame(iClient) || GetConVarInt(ShowBackpack) == 1)
	{
		return 0;
	}
	new iEntity = BackpackIndex[iClient];
	if (!IsValidEntRef(iEntity))
	{
		return 0;
	}
	AcceptEntityInput(iEntity, "kill", -1, -1, 0);
	BackpackIndex[iClient] = -1;
	return 0;
}

public void:OnMapStart()
{
	PrecacheModel("models/props_collectables/backpack.mdl", false);
	return void:0;
}

SetVector(Float:target[3], Float:x, Float:y, Float:z)
{
	target[0] = x;
	target[1] = y;
	target[2] = z;
	return 0;
}

CreateBackpack(iClient)
{
	new var1;
	if (!IsSurvivor(iClient) || !IsPlayerAlive(iClient) || GetConVarInt(ShowBackpack) == 1)
	{
		return 0;
	}
	new iEntity = BackpackIndex[iClient];
	if (IsValidEntRef(iEntity))
	{
		AcceptEntityInput(iEntity, "kill", -1, -1, 0);
	}
	iEntity = CreateEntityByName("prop_dynamic_ornament", -1);
	if (0 > iEntity)
	{
		return 0;
	}
	DispatchKeyValue(iEntity, "model", "models/props_collectables/backpack.mdl");
	SetEntityRenderMode(iEntity, RenderMode:1);
	SetEntityRenderColor(iEntity, 25, 0, 0, 255);
	DispatchSpawn(iEntity);
	ActivateEntity(iEntity);
	SetEntPropFloat(iEntity, PropType:0, "m_flModelScale", 0.66, 0);
	SetVariantString("!activator");
	AcceptEntityInput(iEntity, "SetParent", iClient, -1, 0);
	SetVariantString("medkit");
	AcceptEntityInput(iEntity, "SetParentAttachment", iEntity, -1, 0);
	AcceptEntityInput(iEntity, "TurnOn", -1, -1, 0);
	SetVector(Pos, 4.0, 4.0, 2.5);
	SetVector(Ang, 175.0, 85.0, -75.0);
	TeleportEntity(iEntity, Pos, Ang, NULL_VECTOR);
	if (!IsFakeClient(iClient))
	{
		SDKHook(iEntity, SDKHookType:6, Hook_SetTransmit_View);
	}
	BackpackIndex[iClient] = EntIndexToEntRef(iEntity);
	BackpackOwner[iEntity] = GetClientUserId(iClient);
	return 0;
}

public Action:Hook_SetTransmit_View(entity, client)
{
	if (!IsValidEntRef(BackpackIndex[client]))
	{
		return Action:0;
	}
	static iEntOwner;
	iEntOwner = GetClientOfUserId(BackpackOwner[entity]);
	new var1;
	if (iEntOwner < 1 || !IsClientInGame(iEntOwner))
	{
		return Action:0;
	}
	if (GetClientTeam(iEntOwner) == 2)
	{
		if (client != iEntOwner)
		{
			return Action:0;
		}
		if (!IsSurvivorThirdPerson(client))
		{
			return Action:3;
		}
	}
	return Action:0;
}

bool:IsSurvivorThirdPerson(iClient)
{
	if (GetEntPropFloat(iClient, PropType:0, "m_TimeForceExternalView", 0) > GetGameTime())
	{
		return true;
	}
	if (GetEntProp(iClient, PropType:0, "m_iObserverMode", 4, 0) == 1)
	{
		return true;
	}
	if (0 < GetEntPropEnt(iClient, PropType:0, "m_pummelAttacker", 0))
	{
		return true;
	}
	if (0 < GetEntPropEnt(iClient, PropType:0, "m_carryAttacker", 0))
	{
		return true;
	}
	if (0 < GetEntPropEnt(iClient, PropType:0, "m_pounceAttacker", 0))
	{
		return true;
	}
	if (0 < GetEntPropEnt(iClient, PropType:0, "m_jockeyAttacker", 0))
	{
		return true;
	}
	if (0 < GetEntProp(iClient, PropType:0, "m_isHangingFromLedge", 4, 0))
	{
		return true;
	}
	if (0 < GetEntPropEnt(iClient, PropType:0, "m_reviveTarget", 0))
	{
		return true;
	}
	if (GetEntPropFloat(iClient, PropType:0, "m_staggerTimer", 1) > -1.0)
	{
		return true;
	}
	switch (GetEntProp(iClient, PropType:0, "m_iCurrentUseAction", 4, 0))
	{
		case 1:
		{
			static iTarget;
			iTarget = GetEntPropEnt(iClient, PropType:0, "m_useActionTarget", 0);
			if (GetEntPropEnt(iClient, PropType:0, "m_useActionOwner", 0) == iTarget)
			{
				return true;
			}
			if (iClient != iTarget)
			{
				return true;
			}
		}
		case 4, 6, 7, 8, 9, 10:
		{
			return true;
		}
		default:
		{
		}
	}
	static String:sModel[32];
	GetEntPropString(iClient, PropType:1, "m_ModelName", sModel, 31, 0);
	switch (sModel[7])
	{
		case 97:
		{
			switch (GetEntProp(iClient, PropType:0, "m_nSequence", 4, 0))
			{
				case 527, 528, 529, 530, 531, 532, 533, 534, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 772:
				{
					return true;
				}
				default:
				{
				}
			}
		}
		case 98:
		{
			switch (GetEntProp(iClient, PropType:0, "m_nSequence", 4, 0))
			{
				case 620, 621, 622, 623, 624, 625, 626, 661, 662, 664, 665, 666, 667, 668, 670, 671, 672, 673, 674, 680:
				{
					return true;
				}
				default:
				{
				}
			}
		}
		case 99:
		{
			switch (GetEntProp(iClient, PropType:0, "m_nSequence", 4, 0))
			{
				case 620, 621, 622, 623, 624, 625, 626, 651, 652, 653, 654, 656, 657, 658, 659, 660, 661, 662, 663, 669:
				{
					return true;
				}
				default:
				{
				}
			}
		}
		case 100:
		{
			switch (GetEntProp(iClient, PropType:0, "m_nSequence", 4, 0))
			{
				case 629, 630, 631, 632, 633, 634, 668, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 687:
				{
					return true;
				}
				default:
				{
				}
			}
		}
		case 101:
		{
			switch (GetEntProp(iClient, PropType:0, "m_nSequence", 4, 0))
			{
				case 530, 531, 532, 533, 534, 535, 536, 537, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 775:
				{
					return true;
				}
				default:
				{
				}
			}
		}
		case 104:
		{
			switch (GetEntProp(iClient, PropType:0, "m_nSequence", 4, 0))
			{
				case 575, 625, 626, 627, 628, 629, 630, 631, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 684:
				{
					return true;
				}
				default:
				{
				}
			}
		}
		case 110:
		{
			switch (GetEntProp(iClient, PropType:0, "m_nSequence", 4, 0))
			{
				case 536, 537, 538, 539, 540, 541, 542, 543, 809, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 828:
				{
					return true;
				}
				default:
				{
				}
			}
		}
		case 118:
		{
			switch (GetEntProp(iClient, PropType:0, "m_nSequence", 4, 0))
			{
				case 527, 528, 529, 530, 531, 532, 533, 534, 675, 676, 753, 754, 755, 756, 757, 758, 759, 761, 762, 763, 764, 772:
				{
					return true;
				}
				default:
				{
				}
			}
		}
		case 119:
		{
			switch (GetEntProp(iClient, PropType:0, "m_nSequence", 4, 0))
			{
				case 629, 630, 631, 632, 633, 634, 668, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 687:
				{
					return true;
				}
				default:
				{
				}
			}
		}
		default:
		{
		}
	}
	return false;
}

bool:IsValidClient(client)
{
	new var1;
	if (client > 0 && client <= MaxClients && IsClientInGame(client))
	{
		return true;
	}
	return false;
}

bool:IsSurvivor(client)
{
	new var1;
	if (client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 2)
	{
		return true;
	}
	return false;
}

bool:IsPlayerIncapped(client)
{
	if (GetEntProp(client, PropType:0, "m_isIncapacitated", 1, 0))
	{
		return true;
	}
	return false;
}

public bool:TraceRayDontHitPlayers(entity, mask)
{
	new var1;
	if (!entity || entity <= MaxClients || !IsValidEntity(entity))
	{
		return false;
	}
	return true;
}

bool:IsValidEntRef(iEntRef)
{
	static iEntity;
	iEntity = EntRefToEntIndex(iEntRef);
	new var1;
	return iEntRef && iEntity != -1 && IsValidEntity(iEntity);
}

void:CheatCommand(client, String:command[], String:argument1[], String:argument2[])
{
	new userFlags = GetUserFlagBits(client);
	SetUserFlagBits(client, 16384);
	new flags = GetCommandFlags(command);
	SetCommandFlags(command, flags & -16385);
	FakeClientCommand(client, "%s %s %s", command, argument1, argument2);
	SetCommandFlags(command, flags);
	SetUserFlagBits(client, userFlags);
	return void:0;
}

